name: Deploy to GCP Production

on:
  push:
    branches: [main]
    paths:
      - 'services/**'
      - 'clients/web/**'
      - 'keycloak/**'
      - 'apps/**'
  workflow_dispatch:
    inputs:
      service:
        description: 'Service to deploy'
        required: false
        default: 'all'
        type: choice
        options:
          - all
          - gateway
          - hr
          - finance
          - sales
          - support
          - keycloak
          - web
          - website

# Prevent concurrent deployments to production
# New deployments will wait in queue until current deployment completes
concurrency:
  group: deploy-to-gcp-production
  cancel-in-progress: false

env:
  # Region and Zone
  GCP_REGION: ${{ vars.GCP_REGION }}
  GCP_ZONE: ${{ vars.GCP_ZONE }}
  # Infrastructure
  GCP_POSTGRES_INSTANCE: ${{ vars.GCP_POSTGRES_INSTANCE }}
  GCP_VPC_CONNECTOR: ${{ vars.GCP_VPC_CONNECTOR }}
  # Service Accounts
  GCP_SA_MCP_GATEWAY: ${{ vars.GCP_SA_MCP_GATEWAY }}
  GCP_SA_MCP_SERVERS: ${{ vars.GCP_SA_MCP_SERVERS }}
  GCP_SA_KEYCLOAK: ${{ vars.GCP_SA_KEYCLOAK }}
  # GCP Secret Manager secret names
  GCP_SECRET_CLAUDE_API_KEY: ${{ vars.GCP_SECRET_CLAUDE_API_KEY }}
  GCP_SECRET_DB_PASSWORD: ${{ vars.GCP_SECRET_DB_PASSWORD }}
  GCP_SECRET_MONGODB_URI: ${{ vars.GCP_SECRET_MONGODB_URI }}
  GCP_SECRET_KEYCLOAK_ADMIN_PASSWORD: ${{ vars.GCP_SECRET_KEYCLOAK_ADMIN_PASSWORD }}
  GCP_SECRET_KEYCLOAK_DB_PASSWORD: ${{ vars.GCP_SECRET_KEYCLOAK_DB_PASSWORD }}
  # Issue #102: Secret values for syncing to GCP (GitHub is source of truth)
  MCP_HR_SERVICE_CLIENT_SECRET: ${{ secrets.MCP_HR_SERVICE_CLIENT_SECRET }}
  # Keycloak
  KEYCLOAK_DOMAIN: ${{ vars.KEYCLOAK_DOMAIN }}
  KEYCLOAK_REALM: ${{ vars.KEYCLOAK_REALM }}
  # Artifact Registry
  AR_REPO: ${{ vars.GCP_REGION }}-docker.pkg.dev/${{ secrets.GCP_PROJECT_ID }}/tamshai

jobs:
  # ==========================================================================
  # Dynamic URL Discovery
  # Eliminates hardcoded Cloud Run URLs (Phoenix rebuild fix)
  # ==========================================================================
  discover-urls:
    runs-on: ubuntu-latest
    outputs:
      keycloak_url: ${{ steps.discover.outputs.keycloak_url }}
      keycloak_issuer: ${{ steps.discover.outputs.keycloak_issuer }}
      jwks_uri: ${{ steps.discover.outputs.jwks_uri }}
      mcp_gateway_url: ${{ steps.discover.outputs.mcp_gateway_url }}
      mcp_hr_url: ${{ steps.discover.outputs.mcp_hr_url }}
      mcp_finance_url: ${{ steps.discover.outputs.mcp_finance_url }}
      mcp_sales_url: ${{ steps.discover.outputs.mcp_sales_url }}
      mcp_support_url: ${{ steps.discover.outputs.mcp_support_url }}
      postgres_ip: ${{ steps.discover.outputs.postgres_ip }}
    steps:
      - uses: actions/checkout@v4

      - name: Authenticate to GCP
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY_PROD }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Discover Cloud Run URLs and Cloud SQL IP
        id: discover
        run: |
          echo "Discovering GCP resource URLs..."

          # Cloud Run services (may not exist yet during initial Phoenix rebuild)
          KEYCLOAK_URL=$(gcloud run services describe keycloak \
            --region=${{ env.GCP_REGION }} \
            --format="value(status.url)" 2>/dev/null || echo "")
          MCP_GATEWAY_URL=$(gcloud run services describe mcp-gateway \
            --region=${{ env.GCP_REGION }} \
            --format="value(status.url)" 2>/dev/null || echo "")
          MCP_HR_URL=$(gcloud run services describe mcp-hr \
            --region=${{ env.GCP_REGION }} \
            --format="value(status.url)" 2>/dev/null || echo "")
          MCP_FINANCE_URL=$(gcloud run services describe mcp-finance \
            --region=${{ env.GCP_REGION }} \
            --format="value(status.url)" 2>/dev/null || echo "")
          MCP_SALES_URL=$(gcloud run services describe mcp-sales \
            --region=${{ env.GCP_REGION }} \
            --format="value(status.url)" 2>/dev/null || echo "")
          MCP_SUPPORT_URL=$(gcloud run services describe mcp-support \
            --region=${{ env.GCP_REGION }} \
            --format="value(status.url)" 2>/dev/null || echo "")

          # Cloud SQL private IP
          POSTGRES_IP=$(gcloud sql instances describe ${{ env.GCP_POSTGRES_INSTANCE }} \
            --format="value(ipAddresses[0].ipAddress)" 2>/dev/null || echo "")

          # Use domain as the canonical Keycloak URL for token validation
          # (Cloud Run URL is internal, domain is the public endpoint)
          KEYCLOAK_PUBLIC_URL="https://${{ env.KEYCLOAK_DOMAIN }}"

          # Output values (empty strings are OK - services may not exist yet)
          echo "keycloak_url=${KEYCLOAK_URL:-$KEYCLOAK_PUBLIC_URL}" >> $GITHUB_OUTPUT
          echo "keycloak_issuer=${KEYCLOAK_PUBLIC_URL}/auth/realms/${{ env.KEYCLOAK_REALM }}" >> $GITHUB_OUTPUT
          echo "jwks_uri=${KEYCLOAK_PUBLIC_URL}/auth/realms/${{ env.KEYCLOAK_REALM }}/protocol/openid-connect/certs" >> $GITHUB_OUTPUT
          echo "mcp_gateway_url=${MCP_GATEWAY_URL}" >> $GITHUB_OUTPUT
          echo "mcp_hr_url=${MCP_HR_URL}" >> $GITHUB_OUTPUT
          echo "mcp_finance_url=${MCP_FINANCE_URL}" >> $GITHUB_OUTPUT
          echo "mcp_sales_url=${MCP_SALES_URL}" >> $GITHUB_OUTPUT
          echo "mcp_support_url=${MCP_SUPPORT_URL}" >> $GITHUB_OUTPUT
          echo "postgres_ip=${POSTGRES_IP}" >> $GITHUB_OUTPUT

          echo "Discovery complete:"
          echo "  Keycloak: ${KEYCLOAK_URL:-'not deployed yet'}"
          echo "  MCP Gateway: ${MCP_GATEWAY_URL:-'not deployed yet'}"
          echo "  PostgreSQL IP: ${POSTGRES_IP:-'not available yet'}"

  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      gateway: ${{ steps.changes.outputs.gateway }}
      mcp-suite: ${{ steps.changes.outputs.mcp-suite }}
      keycloak: ${{ steps.changes.outputs.keycloak }}
      web: ${{ steps.changes.outputs.web }}
    steps:
      - uses: actions/checkout@v4

      - uses: dorny/paths-filter@v3
        id: changes
        with:
          filters: |
            gateway:
              - 'services/mcp-gateway/**'
            mcp-suite:
              - 'services/mcp-hr/**'
              - 'services/mcp-finance/**'
              - 'services/mcp-sales/**'
              - 'services/mcp-support/**'
            keycloak:
              - 'keycloak/**'
            web:
              - 'clients/web/**'
              - 'apps/tamshai-website/**'

  deploy-gateway:
    needs: [detect-changes, discover-urls]
    if: |
      needs.detect-changes.outputs.gateway == 'true' ||
      github.event.inputs.service == 'all' ||
      github.event.inputs.service == 'gateway'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Authenticate to GCP
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY_PROD }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Configure Docker for Artifact Registry
        run: gcloud auth configure-docker ${{ env.GCP_REGION }}-docker.pkg.dev --quiet

      - name: Build and Push Image
        run: |
          docker build -t ${{ env.AR_REPO }}/mcp-gateway:${{ github.sha }} \
                       -t ${{ env.AR_REPO }}/mcp-gateway:latest \
                       services/mcp-gateway
          docker push ${{ env.AR_REPO }}/mcp-gateway:${{ github.sha }}
          docker push ${{ env.AR_REPO }}/mcp-gateway:latest

      - name: Deploy to Cloud Run
        run: |
          # Use discovered URLs or fallback to well-known public endpoints
          KEYCLOAK_ISSUER="${{ needs.discover-urls.outputs.keycloak_issuer }}"
          JWKS_URI="${{ needs.discover-urls.outputs.jwks_uri }}"
          MCP_HR_URL="${{ needs.discover-urls.outputs.mcp_hr_url }}"
          MCP_FINANCE_URL="${{ needs.discover-urls.outputs.mcp_finance_url }}"
          MCP_SALES_URL="${{ needs.discover-urls.outputs.mcp_sales_url }}"
          MCP_SUPPORT_URL="${{ needs.discover-urls.outputs.mcp_support_url }}"

          # Fallback to domain for Keycloak (always available)
          KEYCLOAK_ISSUER="${KEYCLOAK_ISSUER:-https://${{ env.KEYCLOAK_DOMAIN }}/auth/realms/${{ env.KEYCLOAK_REALM }}}"
          JWKS_URI="${JWKS_URI:-https://${{ env.KEYCLOAK_DOMAIN }}/auth/realms/${{ env.KEYCLOAK_REALM }}/protocol/openid-connect/certs}"

          gcloud run deploy mcp-gateway \
            --image=${{ env.AR_REPO }}/mcp-gateway:${{ github.sha }} \
            --region=${{ env.GCP_REGION }} \
            --platform=managed \
            --service-account=${{ env.GCP_SA_MCP_GATEWAY }}@${{ secrets.GCP_PROJECT_ID }}.iam.gserviceaccount.com \
            --allow-unauthenticated \
            --min-instances=0 \
            --max-instances=2 \
            --memory=1Gi \
            --cpu=1 \
            --timeout=300 \
            --set-secrets=CLAUDE_API_KEY=${{ env.GCP_SECRET_CLAUDE_API_KEY }}:latest \
            --set-env-vars="NODE_ENV=production,KEYCLOAK_URL=https://${{ env.KEYCLOAK_DOMAIN }}/auth,KEYCLOAK_ISSUER=${KEYCLOAK_ISSUER},JWKS_URI=${JWKS_URI},MCP_HR_URL=${MCP_HR_URL},MCP_FINANCE_URL=${MCP_FINANCE_URL},MCP_SALES_URL=${MCP_SALES_URL},MCP_SUPPORT_URL=${MCP_SUPPORT_URL},TOKEN_REVOCATION_FAIL_OPEN=true,MCP_READ_TIMEOUT_MS=30000,MCP_WRITE_TIMEOUT_MS=60000"

      - name: Health Check
        run: |
          echo "Waiting for mcp-gateway to be healthy..."
          for i in {1..12}; do
            URL=$(gcloud run services describe mcp-gateway --region=${{ env.GCP_REGION }} --format="value(status.url)")
            if curl -sf "${URL}/health" > /dev/null 2>&1; then
              echo "mcp-gateway is healthy!"
              exit 0
            fi
            echo "Attempt $i/12: Not ready yet, waiting 10s..."
            sleep 10
          done
          echo "WARNING: mcp-gateway health check timed out"

  deploy-mcp-postgres:
    needs: detect-changes
    if: |
      needs.detect-changes.outputs.mcp-suite == 'true' ||
      github.event.inputs.service == 'all' ||
      github.event.inputs.service == 'hr' ||
      github.event.inputs.service == 'finance'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service: [mcp-hr, mcp-finance]
        include:
          - service: mcp-hr
            port: 3101
            db_name: tamshai_hr
          - service: mcp-finance
            port: 3102
            db_name: tamshai_finance
    steps:
      - uses: actions/checkout@v4

      - name: Authenticate to GCP
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY_PROD }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Configure Docker
        run: gcloud auth configure-docker ${{ env.GCP_REGION }}-docker.pkg.dev --quiet

      - name: Build and Push
        run: |
          docker build -t ${{ env.AR_REPO }}/${{ matrix.service }}:${{ github.sha }} \
                       -t ${{ env.AR_REPO }}/${{ matrix.service }}:latest \
                       services/${{ matrix.service }}
          docker push ${{ env.AR_REPO }}/${{ matrix.service }}:${{ github.sha }}
          docker push ${{ env.AR_REPO }}/${{ matrix.service }}:latest

      - name: Deploy to Cloud Run
        run: |
          gcloud run deploy ${{ matrix.service }} \
            --image=${{ env.AR_REPO }}/${{ matrix.service }}:${{ github.sha }} \
            --region=${{ env.GCP_REGION }} \
            --platform=managed \
            --service-account=${{ env.GCP_SA_MCP_SERVERS }}@${{ secrets.GCP_PROJECT_ID }}.iam.gserviceaccount.com \
            --no-allow-unauthenticated \
            --min-instances=0 \
            --max-instances=2 \
            --memory=512Mi \
            --cpu=1 \
            --timeout=300 \
            --add-cloudsql-instances=${{ secrets.GCP_PROJECT_ID }}:${{ env.GCP_REGION }}:${{ env.GCP_POSTGRES_INSTANCE }} \
            --vpc-connector=${{ env.GCP_VPC_CONNECTOR }} \
            --vpc-egress=private-ranges-only \
            --set-secrets=POSTGRES_PASSWORD=${{ env.GCP_SECRET_DB_PASSWORD }}:latest,MONGODB_URI=${{ env.GCP_SECRET_MONGODB_URI }}:latest \
            --set-env-vars="NODE_ENV=production,POSTGRES_HOST=/cloudsql/${{ secrets.GCP_PROJECT_ID }}:${{ env.GCP_REGION }}:${{ env.GCP_POSTGRES_INSTANCE }},POSTGRES_PORT=5432,POSTGRES_DB=${{ matrix.db_name }},POSTGRES_USER=tamshai"

  deploy-mcp-mongodb:
    needs: detect-changes
    if: |
      needs.detect-changes.outputs.mcp-suite == 'true' ||
      github.event.inputs.service == 'all' ||
      github.event.inputs.service == 'sales' ||
      github.event.inputs.service == 'support'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service: [mcp-sales, mcp-support]
        include:
          - service: mcp-sales
            port: 3103
            db_name: tamshai_sales
          - service: mcp-support
            port: 3104
            db_name: tamshai_support
            backend: mongodb
    steps:
      - uses: actions/checkout@v4

      - name: Authenticate to GCP
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY_PROD }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Configure Docker
        run: gcloud auth configure-docker ${{ env.GCP_REGION }}-docker.pkg.dev --quiet

      - name: Build and Push
        run: |
          docker build -t ${{ env.AR_REPO }}/${{ matrix.service }}:${{ github.sha }} \
                       -t ${{ env.AR_REPO }}/${{ matrix.service }}:latest \
                       services/${{ matrix.service }}
          docker push ${{ env.AR_REPO }}/${{ matrix.service }}:${{ github.sha }}
          docker push ${{ env.AR_REPO }}/${{ matrix.service }}:latest

      - name: Deploy to Cloud Run
        run: |
          # MongoDB services need all-traffic egress for MongoDB Atlas
          gcloud run deploy ${{ matrix.service }} \
            --image=${{ env.AR_REPO }}/${{ matrix.service }}:${{ github.sha }} \
            --region=${{ env.GCP_REGION }} \
            --platform=managed \
            --service-account=${{ env.GCP_SA_MCP_SERVERS }}@${{ secrets.GCP_PROJECT_ID }}.iam.gserviceaccount.com \
            --no-allow-unauthenticated \
            --min-instances=0 \
            --max-instances=2 \
            --memory=512Mi \
            --cpu=1 \
            --timeout=300 \
            --vpc-connector=${{ env.GCP_VPC_CONNECTOR }} \
            --vpc-egress=all-traffic \
            --set-secrets=MONGODB_URI=${{ env.GCP_SECRET_MONGODB_URI }}:latest \
            --set-env-vars="NODE_ENV=production,MONGODB_DB=${{ matrix.db_name }}${{ matrix.backend && format(',SUPPORT_DATA_BACKEND={0}', matrix.backend) || '' }}"

  deploy-keycloak:
    needs: [detect-changes, discover-urls]
    if: |
      needs.detect-changes.outputs.keycloak == 'true' ||
      github.event.inputs.service == 'all' ||
      github.event.inputs.service == 'keycloak'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Authenticate to GCP
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY_PROD }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Configure Docker
        run: gcloud auth configure-docker ${{ env.GCP_REGION }}-docker.pkg.dev --quiet

      - name: Inject TOTP Secret into Realm Export
        env:
          TEST_USER_TOTP_SECRET_RAW: ${{ secrets.TEST_USER_TOTP_SECRET_RAW }}
        run: |
          # Substitute placeholder with actual secret for test-user.journey TOTP
          # The secret is the RAW value (not BASE32) that Keycloak stores internally
          # See docs/testing/TEST_USER_JOURNEY.md for details on raw vs BASE32 secrets
          if [ -z "$TEST_USER_TOTP_SECRET_RAW" ]; then
            echo "ERROR: TEST_USER_TOTP_SECRET_RAW secret not set"
            exit 1
          fi
          sed -i "s/__TEST_USER_TOTP_SECRET__/${TEST_USER_TOTP_SECRET_RAW}/g" keycloak/realm-export.json

      - name: Build and Push
        run: |
          docker build -t ${{ env.AR_REPO }}/keycloak:${{ github.sha }} \
                       -t ${{ env.AR_REPO }}/keycloak:latest \
                       -t ${{ env.AR_REPO }}/keycloak:v2.0.0-postgres \
                       keycloak
          docker push ${{ env.AR_REPO }}/keycloak:${{ github.sha }}
          docker push ${{ env.AR_REPO }}/keycloak:latest
          docker push ${{ env.AR_REPO }}/keycloak:v2.0.0-postgres

      - name: Deploy to Cloud Run
        run: |
          # Use discovered PostgreSQL IP or dynamically query Cloud SQL
          # Note: Discovery requires cloudsql.admin role which may not be available in all jobs
          POSTGRES_IP="${{ needs.discover-urls.outputs.postgres_ip }}"

          # Validate IP format (x.x.x.x) or query Cloud SQL directly
          if ! [[ "$POSTGRES_IP" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "Discovery unavailable or invalid, querying Cloud SQL directly..."
            POSTGRES_IP=$(gcloud sql instances describe ${{ env.GCP_POSTGRES_INSTANCE }} --format="value(ipAddresses[0].ipAddress)" 2>/dev/null || echo "")
            if ! [[ "$POSTGRES_IP" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
              echo "ERROR: Could not determine PostgreSQL IP"
              exit 1
            fi
          fi

          echo "Using PostgreSQL IP: $POSTGRES_IP"

          gcloud run deploy keycloak \
            --image=${{ env.AR_REPO }}/keycloak:${{ github.sha }} \
            --region=${{ env.GCP_REGION }} \
            --platform=managed \
            --service-account=${{ env.GCP_SA_KEYCLOAK }}@${{ secrets.GCP_PROJECT_ID }}.iam.gserviceaccount.com \
            --allow-unauthenticated \
            --min-instances=1 \
            --max-instances=2 \
            --memory=1Gi \
            --cpu=1 \
            --timeout=600 \
            --vpc-connector=${{ env.GCP_VPC_CONNECTOR }} \
            --vpc-egress=private-ranges-only \
            --set-secrets=KEYCLOAK_ADMIN_PASSWORD=${{ env.GCP_SECRET_KEYCLOAK_ADMIN_PASSWORD }}:latest,KC_DB_PASSWORD=${{ env.GCP_SECRET_KEYCLOAK_DB_PASSWORD }}:latest \
            --set-env-vars="KEYCLOAK_ADMIN=admin,KC_DB=postgres,KC_DB_URL=jdbc:postgresql://${POSTGRES_IP}:5432/keycloak,KC_DB_USERNAME=keycloak,KC_HOSTNAME=${{ env.KEYCLOAK_DOMAIN }},KC_HOSTNAME_STRICT=false,KC_HTTP_PORT=8080,KC_PROXY=edge,KC_PROXY_HEADERS=xforwarded,KC_HTTP_RELATIVE_PATH=/auth,KC_DB_POOL_MAX_SIZE=10,KC_DB_POOL_MIN_SIZE=2"

      - name: Health Check
        run: |
          echo "Waiting for Keycloak to be healthy..."
          for i in {1..12}; do
            if curl -sf "https://${{ env.KEYCLOAK_DOMAIN }}/auth/realms/master/.well-known/openid-configuration" > /dev/null 2>&1; then
              echo "Keycloak is healthy!"
              exit 0
            fi
            echo "Attempt $i/12: Not ready yet, waiting 10s..."
            sleep 10
          done
          echo "WARNING: Keycloak health check timed out"

  sync-keycloak-realm:
    needs: deploy-keycloak
    if: needs.deploy-keycloak.result == 'success'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Authenticate to GCP
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY_PROD }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Wait for Keycloak to be ready
        run: |
          echo "Waiting for Keycloak to be fully ready..."
          for i in {1..6}; do
            # Check master realm (always exists) - ${{ env.KEYCLOAK_REALM }} may be deleted and reimported
            if curl -sf "https://${{ env.KEYCLOAK_DOMAIN }}/auth/realms/master/.well-known/openid-configuration" > /dev/null 2>&1; then
              echo "Keycloak is ready!"
              break
            fi
            echo "Attempt $i/6: Keycloak not ready yet, waiting 10s..."
            sleep 10
          done

          # Final check
          if ! curl -sf "https://${{ env.KEYCLOAK_DOMAIN }}/auth/realms/master/.well-known/openid-configuration" > /dev/null 2>&1; then
            echo "ERROR: Keycloak not ready after 60 seconds"
            exit 1
          fi

      - name: Setup Java
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '21'

      - name: Download Keycloak CLI Tools
        run: |
          echo "Downloading Keycloak CLI tools..."
          # Download Keycloak 25.0.0 (matches our deployed version)
          wget -q https://github.com/keycloak/keycloak/releases/download/25.0.0/keycloak-25.0.0.tar.gz
          tar -xzf keycloak-25.0.0.tar.gz
          echo "KEYCLOAK_HOME=$PWD/keycloak-25.0.0" >> $GITHUB_ENV
          echo "$PWD/keycloak-25.0.0/bin" >> $GITHUB_PATH
          echo "Keycloak CLI tools ready"

      - name: Configure credentials for test-user.journey
        env:
          TEST_USER_TOTP_SECRET_RAW: ${{ secrets.TEST_USER_TOTP_SECRET_RAW }}
          TEST_PASSWORD: ${{ secrets.TEST_USER_PASSWORD }}
        run: |
          # Configure password and TOTP credentials for test-user.journey via Admin API
          # This is necessary because Keycloak's --import-realm doesn't update
          # credentials for existing users (only during initial realm creation)

          echo "Configuring credentials for test-user.journey..."

          # Fetch admin password from GCP Secret Manager
          echo "Fetching admin password from GCP Secret Manager..."
          KEYCLOAK_ADMIN_PASSWORD=$(gcloud secrets versions access latest --secret=${{ env.GCP_SECRET_KEYCLOAK_ADMIN_PASSWORD }})
          if [ -z "$KEYCLOAK_ADMIN_PASSWORD" ]; then
            echo "ERROR: Could not fetch admin password from Secret Manager"
            exit 1
          fi
          echo "Admin password fetched successfully (length: ${#KEYCLOAK_ADMIN_PASSWORD})"
          export KEYCLOAK_ADMIN_PASSWORD

          # Get admin token with verbose error handling
          echo "Requesting admin token from Keycloak..."
          TOKEN_RESPONSE=$(curl -s -X POST "https://${{ env.KEYCLOAK_DOMAIN }}/auth/realms/master/protocol/openid-connect/token" \
            -H "Content-Type: application/x-www-form-urlencoded" \
            --data-urlencode "username=admin" \
            --data-urlencode "password=${KEYCLOAK_ADMIN_PASSWORD}" \
            -d "grant_type=password" \
            -d "client_id=admin-cli" 2>&1)

          TOKEN=$(echo "$TOKEN_RESPONSE" | jq -r '.access_token // empty')
          ERROR=$(echo "$TOKEN_RESPONSE" | jq -r '.error_description // .error // empty')

          if [ -z "$TOKEN" ]; then
            echo "ERROR: Could not get admin token"
            echo "Response: $TOKEN_RESPONSE"
            if [ -n "$ERROR" ]; then
              echo "Error details: $ERROR"
            fi
            exit 1
          fi
          echo "Admin token obtained successfully"

          # Get test-user.journey user ID
          USER_ID=$(curl -sf "https://${{ env.KEYCLOAK_DOMAIN }}/auth/admin/realms/${{ env.KEYCLOAK_REALM }}/users?username=test-user.journey" \
            -H "Authorization: Bearer $TOKEN" | jq -r '.[0].id')

          if [ -z "$USER_ID" ] || [ "$USER_ID" = "null" ]; then
            echo "ERROR: Could not find test-user.journey user"
            exit 1
          fi
          echo "Found user ID: $USER_ID"

          # Reset password for test-user.journey
          echo "Resetting password for test-user.journey..."
          if [ -z "$TEST_PASSWORD" ]; then
            echo "ERROR: TEST_USER_PASSWORD secret not set"
            exit 1
          fi
          # Use jq for proper JSON encoding (handles special chars like @)
          PASSWORD_JSON=$(jq -n --arg pass "$TEST_PASSWORD" '{"type":"password","value":$pass,"temporary":false}')
          RESET_RESPONSE=$(curl -s -w "\n%{http_code}" -X PUT "https://${{ env.KEYCLOAK_DOMAIN }}/auth/admin/realms/${{ env.KEYCLOAK_REALM }}/users/${USER_ID}/reset-password" \
            -H "Authorization: Bearer $TOKEN" \
            -H "Content-Type: application/json" \
            -d "$PASSWORD_JSON")
          HTTP_CODE=$(echo "$RESET_RESPONSE" | tail -n1)
          if [ "$HTTP_CODE" != "204" ]; then
            echo "ERROR: Failed to reset password (HTTP $HTTP_CODE)"
            echo "Response: $(echo "$RESET_RESPONSE" | head -n-1)"
            exit 1
          fi
          echo "Password reset successfully"

          # Configure TOTP using set-user-totp.sh script
          # The script handles: auth, finding user, deleting old OTP, creating new OTP via Admin API
          # IMPORTANT: TEST_USER_TOTP_SECRET_RAW must be the RAW secret (not BASE32)
          # The corresponding BASE32 version is used by E2E tests with oathtool
          echo "Configuring TOTP credential via set-user-totp.sh..."
          if [ -z "$TEST_USER_TOTP_SECRET_RAW" ]; then
            echo "ERROR: TEST_USER_TOTP_SECRET_RAW secret not set"
            exit 1
          fi

          chmod +x keycloak/scripts/set-user-totp.sh
          AUTO_CONFIRM=true ./keycloak/scripts/set-user-totp.sh prod test-user.journey "$TEST_USER_TOTP_SECRET_RAW"

          echo "TOTP configuration complete."

      - name: Wait for Realm Reimport
        run: |
          echo "Waiting for Keycloak to reimport realm..."
          for i in {1..12}; do
            if curl -sf "https://${{ env.KEYCLOAK_DOMAIN }}/auth/realms/${{ env.KEYCLOAK_REALM }}/.well-known/openid-configuration" > /dev/null 2>&1; then
              echo "Realm ${{ env.KEYCLOAK_REALM }} is available!"
              break
            fi
            echo "Attempt $i/12: Realm not ready yet, waiting 10s..."
            sleep 10
          done

      - name: Sync Realm Configuration
        env:
          KEYCLOAK_URL: https://${{ env.KEYCLOAK_DOMAIN }}/auth
          KEYCLOAK_ADMIN: admin
        run: |
          echo "Running realm sync directly from GitHub Actions runner..."
          echo "This eliminates Cloud Run Job overhead (container pull + JVM startup)"

          # Fetch secrets from GCP Secret Manager (single source of truth for prod)
          export KEYCLOAK_ADMIN_PASSWORD=$(gcloud secrets versions access latest --secret=${{ env.GCP_SECRET_KEYCLOAK_ADMIN_PASSWORD }})
          export MCP_HR_SERVICE_CLIENT_SECRET=$(gcloud secrets versions access latest --secret=mcp-hr-service-client-secret)

          # Make script executable and run it
          chmod +x keycloak/scripts/sync-realm.sh

          # Run sync with error handling
          if keycloak/scripts/sync-realm.sh prod; then
            echo "Realm sync completed successfully!"
          else
            echo "WARNING: Realm sync had errors but continuing deployment"
            # Don't fail the deployment - sync errors are usually recoverable
          fi

  deploy-static-website:
    needs: detect-changes
    if: |
      needs.detect-changes.outputs.web == 'true' ||
      github.event.inputs.service == 'all' ||
      github.event.inputs.service == 'web' ||
      github.event.inputs.service == 'website'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Authenticate to GCP
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY_PROD }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Deploy Marketing Website to GCS
        run: |
          # Deploy public marketing website at root (excluding markdown files)
          gcloud storage rsync --recursive apps/tamshai-website/src gs://prod.tamshai.com --exclude='\.md$'

          # Set cache control for index.html
          gcloud storage objects update gs://prod.tamshai.com/index.html --cache-control="no-cache,must-revalidate"

  deploy-web-portal:
    needs: [detect-changes, discover-urls]
    if: |
      needs.detect-changes.outputs.web == 'true' ||
      github.event.inputs.service == 'all' ||
      github.event.inputs.service == 'web'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Authenticate to GCP
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY_PROD }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Configure Docker for Artifact Registry
        run: gcloud auth configure-docker ${{ env.GCP_REGION }}-docker.pkg.dev --quiet

      - name: Build and Push Web Apps Image
        run: |
          # Use discovered MCP Gateway URL or fetch dynamically
          MCP_GATEWAY_URL="${{ needs.discover-urls.outputs.mcp_gateway_url }}"
          if [ -z "$MCP_GATEWAY_URL" ]; then
            echo "Discovering MCP Gateway URL..."
            MCP_GATEWAY_URL=$(gcloud run services describe mcp-gateway \
              --region=${{ env.GCP_REGION }} \
              --format="value(status.url)" 2>/dev/null || echo "")
          fi

          # Use domain for Keycloak (always available via domain mapping)
          KEYCLOAK_URL="https://${{ env.KEYCLOAK_DOMAIN }}/auth/realms/${{ env.KEYCLOAK_REALM }}"

          echo "Building web-portal with:"
          echo "  KEYCLOAK_URL: $KEYCLOAK_URL"
          echo "  MCP_GATEWAY_URL: ${MCP_GATEWAY_URL:-'will be set at runtime'}"

          # Build ALL web apps (portal, hr, finance, sales, support) using unified Dockerfile
          docker build \
            -f clients/web/Dockerfile.prod \
            -t ${{ env.AR_REPO }}/web-portal:${{ github.sha }} \
            -t ${{ env.AR_REPO }}/web-portal:latest \
            --build-arg VITE_KEYCLOAK_URL="$KEYCLOAK_URL" \
            --build-arg VITE_KEYCLOAK_CLIENT_ID=web-portal \
            --build-arg VITE_API_GATEWAY_URL="$MCP_GATEWAY_URL" \
            --build-arg VITE_MCP_GATEWAY_URL="$MCP_GATEWAY_URL" \
            --build-arg VITE_RELEASE_TAG=v1.0.0 \
            .
          docker push ${{ env.AR_REPO }}/web-portal:${{ github.sha }}
          docker push ${{ env.AR_REPO }}/web-portal:latest

      - name: Deploy to Cloud Run
        run: |
          gcloud run deploy web-portal \
            --image=${{ env.AR_REPO }}/web-portal:${{ github.sha }} \
            --region=${{ env.GCP_REGION }} \
            --platform=managed \
            --service-account=${{ env.GCP_SA_MCP_GATEWAY }}@${{ secrets.GCP_PROJECT_ID }}.iam.gserviceaccount.com \
            --allow-unauthenticated \
            --min-instances=0 \
            --max-instances=2 \
            --memory=512Mi \
            --cpu=1 \
            --timeout=60 \
            --port=80

      - name: Health Check
        run: |
          echo "Waiting for web-portal to be healthy..."
          for i in {1..6}; do
            URL=$(gcloud run services describe web-portal --region=${{ env.GCP_REGION }} --format="value(status.url)")
            if curl -sf "${URL}/" > /dev/null 2>&1; then
              echo "web-portal is healthy!"
              exit 0
            fi
            echo "Attempt $i/6: Not ready yet, waiting 10s..."
            sleep 10
          done
          echo "WARNING: web-portal health check timed out"

  notify:
    needs: [deploy-gateway, deploy-mcp-postgres, deploy-mcp-mongodb, deploy-keycloak, deploy-static-website, deploy-web-portal]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Deployment Summary
        run: |
          echo "## Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "| Component | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-----------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Gateway | ${{ needs.deploy-gateway.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| MCP PostgreSQL (HR, Finance) | ${{ needs.deploy-mcp-postgres.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| MCP MongoDB (Sales, Support) | ${{ needs.deploy-mcp-mongodb.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Keycloak | ${{ needs.deploy-keycloak.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Static Website | ${{ needs.deploy-static-website.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Web Portal | ${{ needs.deploy-web-portal.result }} |" >> $GITHUB_STEP_SUMMARY
