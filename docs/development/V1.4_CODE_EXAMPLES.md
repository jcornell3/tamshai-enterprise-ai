# Architecture v1.4 Code Examples

**Purpose**: Quick reference guide for developers implementing v1.4 patterns
**Audience**: Backend developers working on MCP servers
**Version**: 1.4.0

---

## Table of Contents

1. [LIMIT+1 Truncation Detection](#limit1-truncation-detection)
2. [Human-in-the-Loop Confirmations](#human-in-the-loop-confirmations)
3. [LLM-Friendly Error Responses](#llm-friendly-error-responses)
4. [SSE Streaming (Gateway Only)](#sse-streaming-gateway-only)

---

## LIMIT+1 Truncation Detection

**Purpose**: Detect when query results exceed the limit and warn users
**Reference**: Section 5.3, Article III.2 (50-record limit)

### PostgreSQL Example (HR/Finance)

```typescript
// services/mcp-hr/src/tools/list-employees.ts:83-149

export async function listEmployees(
  input: ListEmployeesInput,
  userContext: UserContext
): Promise<MCPToolResponse<Employee[]>> {
  const { limit } = validated; // Max 50

  // v1.4: Query with LIMIT + 1 to detect truncation
  const queryLimit = limit + 1;

  const result = await queryWithRLS<Employee>(
    userContext,
    `
    SELECT ... FROM hr.employees
    WHERE ...
    ORDER BY e.last_name, e.first_name
    LIMIT $${paramIndex}
    `,
    [...values, queryLimit]
  );

  // v1.4: Check if results are truncated
  const isTruncated = result.rowCount! > limit;
  const employees = isTruncated
    ? result.rows.slice(0, limit)  // Return only requested limit
    : result.rows;

  // v1.4: Build truncation metadata if needed
  let metadata: TruncationMetadata | undefined;

  if (isTruncated) {
    metadata = {
      truncated: true,
      returnedCount: employees.length,
      warning: `⚠️ Showing ${employees.length} of 50+ employees. Results are incomplete. Please refine your query.`,
    };
  }

  return createSuccessResponse(employees, metadata);
}
```

### MongoDB Example (Sales)

```typescript
// services/mcp-sales/src/index.ts:58-92

async function listOpportunities(
  input: any,
  userContext: UserContext
): Promise<MCPToolResponse<any[]>> {
  const { limit } = ListOpportunitiesInputSchema.parse(input);

  // v1.4: LIMIT+1 pattern
  const queryLimit = limit + 1;
  const opportunities = await collection
    .find(filter)
    .limit(queryLimit)
    .toArray();

  const isTruncated = opportunities.length > limit;
  const results = isTruncated
    ? opportunities.slice(0, limit)
    : opportunities;

  let metadata: TruncationMetadata | undefined;
  if (isTruncated) {
    metadata = {
      truncated: true,
      returnedCount: results.length,
      warning: `⚠️ Showing ${results.length} of 50+ opportunities. Results are incomplete.`,
    };
  }

  return createSuccessResponse(results, metadata);
}
```

### Elasticsearch Example (Support)

```typescript
// services/mcp-support/src/index.ts:68-108

async function searchTickets(
  input: any,
  userContext: UserContext
): Promise<MCPToolResponse<any[]>> {
  const { limit } = SearchTicketsInputSchema.parse(input);

  // v1.4: LIMIT+1 pattern
  const queryLimit = limit + 1;

  const result = await esClient.search({
    index: 'support_tickets',
    body: {
      query: { ... },
      size: queryLimit,
    },
  });

  const hits = result.hits.hits;
  const isTruncated = hits.length > limit;
  const results = isTruncated
    ? hits.slice(0, limit)
    : hits;

  let metadata: TruncationMetadata | undefined;
  if (isTruncated) {
    metadata = {
      truncated: true,
      returnedCount: results.length,
      warning: `⚠️ Showing ${results.length} of 50+ tickets. Results are incomplete.`,
    };
  }

  return createSuccessResponse(results, metadata);
}
```

### Key Points

✅ **DO**:
- Always query for `limit + 1` records
- Check if `rowCount/length > limit`
- Return only `limit` records to client
- Include `metadata.truncated = true` when truncated
- Provide actionable warning message

❌ **DON'T**:
- Query for exact `limit` (can't detect truncation)
- Return `limit + 1` records to client
- Omit warning message
- Use generic warning text (be specific about filters)

---

## Human-in-the-Loop Confirmations

**Purpose**: Require user approval for destructive write operations
**Reference**: Section 5.6

### Step 1: Request Confirmation (Tool Implementation)

```typescript
// services/mcp-hr/src/tools/delete-employee.ts:61-145

export async function deleteEmployee(
  input: DeleteEmployeeInput,
  userContext: UserContext
): Promise<MCPToolResponse<any>> {
  return withErrorHandling('delete_employee', async () => {
    // 1. Check permissions
    if (!hasDeletePermission(userContext.roles)) {
      return handleInsufficientPermissions('hr-write or executive', userContext.roles);
    }

    const { employeeId, reason } = DeleteEmployeeInputSchema.parse(input);

    // 2. Validate business rules
    if (employeeId === userContext.userId) {
      return handleCannotDeleteSelf(userContext.userId);
    }

    // 3. Fetch record details
    const employeeResult = await queryWithRLS(userContext, `
      SELECT e.employee_id, e.first_name, e.last_name, e.email, e.department
      FROM hr.employees e
      WHERE e.employee_id = $1
    `, [employeeId]);

    if (employeeResult.rowCount === 0) {
      return handleEmployeeNotFound(employeeId);
    }

    const employee = employeeResult.rows[0];

    // 4. Generate confirmation ID
    const confirmationId = uuidv4();

    // 5. Store pending action in Redis (5-minute TTL)
    const confirmationData = {
      action: 'delete_employee',
      mcpServer: 'hr',
      userId: userContext.userId,
      timestamp: Date.now(),
      employeeId,
      employeeName: `${employee.first_name} ${employee.last_name}`,
      employeeEmail: employee.email,
      reason: reason || 'No reason provided',
    };

    await storePendingConfirmation(confirmationId, confirmationData, 300);

    // 6. Return pending_confirmation response
    const message = `⚠️ Delete employee ${employee.first_name} ${employee.last_name} (${employee.email})?

Department: ${employee.department}
${reason ? `Reason: ${reason}` : ''}

This action will permanently mark the employee as inactive and cannot be undone.`;

    return createPendingConfirmationResponse(
      confirmationId,
      message,
      confirmationData
    );
  });
}
```

### Step 2: Execute Confirmed Action

```typescript
// services/mcp-hr/src/tools/delete-employee.ts:154-193

export async function executeDeleteEmployee(
  confirmationData: Record<string, unknown>,
  userContext: UserContext
): Promise<MCPToolResponse<any>> {
  return withErrorHandling('execute_delete_employee', async () => {
    const employeeId = confirmationData.employeeId as string;

    // Perform the actual deletion
    const result = await queryWithRLS(
      userContext,
      `
      UPDATE hr.employees
      SET employment_status = 'terminated',
          updated_at = NOW(),
          updated_by = $2
      WHERE employee_id = $1
        AND employment_status = 'active'
      RETURNING employee_id, first_name, last_name
      `,
      [employeeId, userContext.userId]
    );

    if (result.rowCount === 0) {
      return handleEmployeeNotFound(employeeId);
    }

    const deleted = result.rows[0];

    return createSuccessResponse({
      success: true,
      message: `Employee ${deleted.first_name} ${deleted.last_name} has been successfully deleted`,
      employeeId: deleted.employee_id,
    });
  });
}
```

### Step 3: Wire Up Execute Endpoint

```typescript
// services/mcp-hr/src/index.ts:232-276

app.post('/execute', async (req: Request, res: Response) => {
  try {
    const { action, data, userContext } = req.body;

    if (!userContext?.userId) {
      res.status(400).json({
        status: 'error',
        code: 'MISSING_USER_CONTEXT',
        message: 'User context is required',
      });
      return;
    }

    logger.info('Executing confirmed action', { action, userId: userContext.userId });

    let result: MCPToolResponse;

    switch (action) {
      case 'delete_employee':
        result = await executeDeleteEmployee(data, userContext);
        break;

      default:
        result = {
          status: 'error',
          code: 'UNKNOWN_ACTION',
          message: `Unknown action: ${action}`,
          suggestedAction: 'Check the action name and try again',
        };
    }

    res.json(result);
  } catch (error) {
    logger.error('Execute error:', error);
    res.status(500).json({
      status: 'error',
      code: 'EXECUTION_FAILED',
      message: 'Failed to execute confirmed action',
    });
  }
});
```

### Gateway Confirmation Endpoint

```typescript
// services/mcp-gateway/src/index.ts:618-691

app.post('/api/confirm/:confirmationId', authMiddleware, async (req: Request, res: Response) => {
  try {
    const { confirmationId } = req.params;
    const { approved } = req.body;

    // 1. Retrieve pending confirmation from Redis
    const pendingAction = await getPendingConfirmation(confirmationId);

    if (!pendingAction) {
      res.status(404).json({
        error: 'Confirmation not found or expired',
        message: '⏱️ Confirmation expired (5-minute TTL). Please retry the operation.',
      });
      return;
    }

    // 2. Verify user ownership
    if (pendingAction.userId !== userContext.userId) {
      res.status(403).json({
        error: 'Unauthorized',
        message: 'You can only approve your own confirmations',
      });
      return;
    }

    // 3. Handle denial
    if (!approved) {
      await deletePendingConfirmation(confirmationId);
      logger.info('Confirmation denied', { confirmationId, userId: userContext.userId });

      res.json({
        status: 'cancelled',
        message: 'Action cancelled by user',
      });
      return;
    }

    // 4. Execute the confirmed action
    const mcpServerUrl = getMcpServerUrl(pendingAction.mcpServer as string);

    const executeResponse = await axios.post(
      `${mcpServerUrl}/execute`,
      {
        action: pendingAction.action,
        data: pendingAction,
        userContext,
      }
    );

    // 5. Delete confirmation from Redis
    await deletePendingConfirmation(confirmationId);

    logger.info('Confirmation executed', {
      confirmationId,
      action: pendingAction.action,
      userId: userContext.userId,
    });

    res.json(executeResponse.data);
  } catch (error) {
    logger.error('Confirmation error:', error);
    res.status(500).json({
      error: 'Confirmation failed',
      message: 'Failed to process confirmation',
    });
  }
});
```

### Redis Utility

```typescript
// services/mcp-hr/src/utils/redis.ts

import Redis from 'ioredis';

const redis = new Redis({
  host: process.env.REDIS_HOST || 'localhost',
  port: parseInt(process.env.REDIS_PORT || '6380'),
});

export async function storePendingConfirmation(
  confirmationId: string,
  data: Record<string, unknown>,
  ttlSeconds: number = 300
): Promise<void> {
  const key = `pending:${confirmationId}`;
  await redis.setex(key, ttlSeconds, JSON.stringify(data));
}

export async function getPendingConfirmation(
  confirmationId: string
): Promise<Record<string, unknown> | null> {
  const key = `pending:${confirmationId}`;
  const data = await redis.get(key);
  return data ? JSON.parse(data) : null;
}

export async function deletePendingConfirmation(
  confirmationId: string
): Promise<void> {
  const key = `pending:${confirmationId}`;
  await redis.del(key);
}
```

### Key Points

✅ **DO**:
- Generate UUID for confirmation ID
- Store all action details in Redis
- Set 5-minute TTL (300 seconds)
- Validate business rules BEFORE returning confirmation
- Show clear confirmation message with action details
- Verify user ownership in Gateway
- Delete confirmation after execution (success or denial)

❌ **DON'T**:
- Execute action immediately without confirmation
- Store sensitive data like passwords in confirmation
- Allow users to confirm others' actions
- Skip business rule validation
- Forget to set TTL (confirmations must expire)

---

## LLM-Friendly Error Responses

**Purpose**: Enable AI self-correction with structured errors
**Reference**: Section 7.4, Article II.3

### Type Definitions

```typescript
// services/mcp-hr/src/types/response.ts

export interface MCPErrorResponse {
  status: 'error';
  code: string;
  message: string;
  suggestedAction?: string;
  details?: Record<string, unknown>;
}

export type MCPToolResponse<T = unknown> =
  | MCPSuccessResponse<T>
  | MCPErrorResponse
  | MCPPendingConfirmationResponse;

export function createErrorResponse(
  code: string,
  message: string,
  suggestedAction?: string,
  details?: Record<string, unknown>
): MCPErrorResponse {
  return { status: 'error', code, message, suggestedAction, details };
}
```

### Error Handler Implementation

```typescript
// services/mcp-hr/src/utils/error-handler.ts

export enum ErrorCode {
  EMPLOYEE_NOT_FOUND = 'EMPLOYEE_NOT_FOUND',
  INSUFFICIENT_PERMISSIONS = 'INSUFFICIENT_PERMISSIONS',
  CANNOT_DELETE_SELF = 'CANNOT_DELETE_SELF',
  DATABASE_ERROR = 'DATABASE_ERROR',
}

export function handleEmployeeNotFound(employeeId: string): MCPErrorResponse {
  logger.warn('Employee not found', { employeeId });

  return createErrorResponse(
    ErrorCode.EMPLOYEE_NOT_FOUND,
    `Employee with ID "${employeeId}" was not found`,
    'Please verify the employee ID is correct. You can search for employees using the list_employees tool with filters.',
    { employeeId }
  );
}

export function handleInsufficientPermissions(
  requiredRole: string,
  userRoles: string[]
): MCPErrorResponse {
  logger.warn('Insufficient permissions', { requiredRole, userRoles });

  return createErrorResponse(
    ErrorCode.INSUFFICIENT_PERMISSIONS,
    `This operation requires "${requiredRole}" role. You have: ${userRoles.join(', ')}`,
    'Please contact your administrator if you need additional permissions.',
    { requiredRole, userRoles }
  );
}

export function handleDatabaseError(
  error: Error,
  operation: string
): MCPErrorResponse {
  logger.error('Database error', {
    error: error.message,
    stack: error.stack,
    operation,
  });

  return createErrorResponse(
    ErrorCode.DATABASE_ERROR,
    'A database error occurred while processing your request',
    'Please try again. If the problem persists, contact support.',
    { operation, errorMessage: error.message }
  );
}
```

### Usage in Tools

```typescript
// services/mcp-hr/src/tools/get-employee.ts

export async function getEmployee(
  input: GetEmployeeInput,
  userContext: UserContext
): Promise<MCPToolResponse<Employee>> {
  return withErrorHandling('get_employee', async () => {
    const { employeeId } = GetEmployeeInputSchema.parse(input);

    try {
      const result = await queryWithRLS<Employee>(
        userContext,
        `SELECT ... FROM hr.employees WHERE employee_id = $1`,
        [employeeId]
      );

      if (result.rowCount === 0) {
        return handleEmployeeNotFound(employeeId);
      }

      return createSuccessResponse(result.rows[0]);
    } catch (error) {
      return handleDatabaseError(error as Error, 'get_employee');
    }
  }) as Promise<MCPToolResponse<Employee>>;
}
```

### Error Handler Wrapper

```typescript
// services/mcp-hr/src/utils/error-handler.ts

export async function withErrorHandling<T>(
  operation: string,
  fn: () => Promise<MCPToolResponse<T>>
): Promise<MCPToolResponse<T>> {
  try {
    return await fn();
  } catch (error: any) {
    // Handle Zod validation errors
    if (error.name === 'ZodError') {
      return handleValidationError(error);
    }

    // Handle all other errors
    logger.error('Unexpected error in operation', {
      operation,
      error: error.message,
      stack: error.stack,
    });

    return createErrorResponse(
      ErrorCode.INTERNAL_ERROR,
      'An unexpected error occurred',
      'Please try again. If the problem persists, contact support.',
      { operation }
    );
  }
}
```

### Key Points

✅ **DO**:
- Use discriminated union `MCPToolResponse` type
- Always include `suggestedAction` field
- Provide specific, actionable error messages
- Log errors with full context
- Use error codes for programmatic handling
- Include relevant details in `details` field

❌ **DON'T**:
- Throw raw exceptions to AI
- Use generic error messages like "Error occurred"
- Expose internal implementation details
- Return HTTP error codes in response body
- Skip logging errors

---

## SSE Streaming (Gateway Only)

**Purpose**: Prevent timeouts during 30-60 second Claude reasoning
**Reference**: Section 6.1

### SSE Endpoint Implementation

```typescript
// services/mcp-gateway/src/index.ts:494-605

app.get('/api/query', authMiddleware, async (req: Request, res: Response) => {
  try {
    const { query } = req.query;
    const userContext = (req as any).userContext;

    // Set SSE headers
    res.setHeader('Content-Type', 'text/event-stream');
    res.setHeader('Cache-Control', 'no-cache');
    res.setHeader('Connection', 'keep-alive');

    // Keep connection alive
    res.flushHeaders();

    // 1. Query MCP servers for tool results
    const mcpResults = await queryMcpServers(query, userContext);

    // 2. Check for truncation
    const hasTruncation = mcpResults.some((result) => {
      const mcpResponse = result.data as MCPToolResponse;
      return isSuccessResponse(mcpResponse) && mcpResponse.metadata?.truncated;
    });

    // 3. Build system prompt with truncation warning
    let truncationWarning = '';
    if (hasTruncation) {
      truncationWarning = `\n\nIMPORTANT: Some of the data results have been truncated due to the 50-record limit. You MUST inform the user that the results are incomplete and suggest they refine their query with more specific filters.`;
    }

    // 4. Check for pending confirmations
    const hasPendingConfirmation = mcpResults.some((result) => {
      const mcpResponse = result.data as MCPToolResponse;
      return isPendingConfirmationResponse(mcpResponse);
    });

    if (hasPendingConfirmation) {
      // Return pending confirmation immediately (no Claude call)
      const confirmationResponse = mcpResults.find((r) =>
        isPendingConfirmationResponse(r.data as MCPToolResponse)
      );
      res.write(`data: ${JSON.stringify(confirmationResponse)}\n\n`);
      res.write('data: [DONE]\n\n');
      res.end();
      return;
    }

    // 5. Call Claude API with streaming
    const stream = await anthropic.messages.create({
      model: 'claude-sonnet-4-20250514',
      max_tokens: 4096,
      system: systemPrompt + truncationWarning,
      messages: [{ role: 'user', content: query as string }],
      tools: buildMcpTools(userContext.mcpServers),
      stream: true,
    });

    // 6. Stream Claude response
    for await (const chunk of stream) {
      if (chunk.type === 'content_block_start') {
        res.write(`data: ${JSON.stringify({ type: 'start' })}\n\n`);
      } else if (chunk.type === 'content_block_delta') {
        if (chunk.delta.type === 'text_delta') {
          res.write(`data: ${JSON.stringify({
            type: 'text',
            text: chunk.delta.text
          })}\n\n`);
        }
      } else if (chunk.type === 'message_stop') {
        res.write(`data: ${JSON.stringify({ type: 'stop' })}\n\n`);
      }
    }

    // 7. Send completion marker
    res.write('data: [DONE]\n\n');
    res.end();

    logger.info('SSE query completed', { requestId, durationMs });
  } catch (error) {
    logger.error('SSE query error:', error);
    res.write(`data: ${JSON.stringify({ type: 'error', error: 'Query failed' })}\n\n`);
    res.end();
  }
});
```

### Client-Side SSE Consumer (Example)

```typescript
// Sample web client

const eventSource = new EventSource('/api/query?query=' + encodeURIComponent(query), {
  headers: {
    'Authorization': `Bearer ${token}`
  }
});

eventSource.onmessage = (event) => {
  if (event.data === '[DONE]') {
    eventSource.close();
    return;
  }

  const data = JSON.parse(event.data);

  if (data.type === 'text') {
    // Append text to UI
    appendToResponse(data.text);
  } else if (data.type === 'error') {
    // Show error
    showError(data.error);
  }
};

eventSource.onerror = (error) => {
  console.error('SSE error:', error);
  eventSource.close();
};
```

### Key Points

✅ **DO**:
- Set proper SSE headers (`text/event-stream`, `no-cache`, `keep-alive`)
- Call `res.flushHeaders()` immediately
- Stream chunks as `data: {json}\n\n` format
- Send `[DONE]` marker when complete
- Handle errors gracefully without closing connection abruptly

❌ **DON'T**:
- Use POST request for SSE (must be GET)
- Forget to close EventSource on client side
- Send non-JSON data (except `[DONE]`)
- Block the response (defeats the purpose of streaming)

---

## Testing Your v1.4 Implementation

### Unit Test Example

```typescript
// tests/unit/list-employees.test.ts

describe('list_employees truncation detection', () => {
  it('should detect truncation when results exceed limit', async () => {
    const input = { limit: 50 };
    const userContext = {
      userId: 'user-id',
      username: 'alice.chen',
      roles: ['hr-read'],
    };

    // Mock database to return 51 employees
    jest.spyOn(db, 'queryWithRLS').mockResolvedValue({
      rowCount: 51,
      rows: Array(51).fill({ employee_id: 'id', first_name: 'John' }),
    });

    const result = await listEmployees(input, userContext);

    expect(result.status).toBe('success');
    expect(result.data.length).toBe(50); // Only 50 returned
    expect(result.metadata?.truncated).toBe(true);
    expect(result.metadata?.warning).toContain('50 of 50+');
  });

  it('should not show truncation when results are within limit', async () => {
    const input = { limit: 50 };
    const userContext = {
      userId: 'user-id',
      username: 'alice.chen',
      roles: ['hr-read'],
    };

    // Mock database to return 30 employees
    jest.spyOn(db, 'queryWithRLS').mockResolvedValue({
      rowCount: 30,
      rows: Array(30).fill({ employee_id: 'id', first_name: 'John' }),
    });

    const result = await listEmployees(input, userContext);

    expect(result.status).toBe('success');
    expect(result.data.length).toBe(30);
    expect(result.metadata).toBeUndefined(); // No truncation
  });
});
```

### Integration Test Example

```bash
# Test truncation detection
curl -X POST "http://localhost:3101/tools/list_employees" \
  -H "Content-Type: application/json" \
  -d '{
    "input": { "limit": 50 },
    "userContext": {
      "userId": "user-id",
      "username": "alice.chen",
      "roles": ["hr-read"]
    }
  }' | jq '.metadata.truncated'

# Expected: true (if more than 50 employees exist)

# Test confirmation flow
CONFIRMATION_ID=$(curl -X POST "http://localhost:3101/tools/delete_employee" \
  -H "Content-Type: application/json" \
  -d '{
    "input": { "employeeId": "employee-uuid" },
    "userContext": {
      "userId": "user-id",
      "username": "alice.chen",
      "roles": ["hr-write"]
    }
  }' | jq -r '.confirmationId')

echo "Confirmation ID: $CONFIRMATION_ID"

# Approve via Gateway
curl -X POST "http://localhost:3100/api/confirm/$CONFIRMATION_ID" \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{ "approved": true }' | jq .
```

---

## Quick Reference Checklist

When implementing a new MCP server with v1.4 features:

### Read Tools (List/Search)
- [ ] Implement LIMIT+1 query pattern
- [ ] Check if `rowCount/length > limit`
- [ ] Return only `limit` records
- [ ] Include `metadata.truncated = true` when truncated
- [ ] Provide specific warning message

### Write Tools (Destructive Operations)
- [ ] Generate UUID confirmation ID
- [ ] Validate business rules BEFORE confirmation
- [ ] Store action details in Redis (5-min TTL)
- [ ] Return `pending_confirmation` status
- [ ] Implement separate `execute*` function
- [ ] Wire up `/execute` endpoint

### Error Handling
- [ ] Define error code enum
- [ ] Create handler functions for each error type
- [ ] Always include `suggestedAction` field
- [ ] Use `withErrorHandling` wrapper
- [ ] Log all errors with context

### Testing
- [ ] Unit tests for truncation detection
- [ ] Unit tests for confirmation flow
- [ ] Integration tests with real databases
- [ ] Manual testing with curl commands

---

*Last Updated: December 8, 2025*
*Architecture Version: 1.4.0*
*For Questions: Refer to docs/architecture/overview.md*
