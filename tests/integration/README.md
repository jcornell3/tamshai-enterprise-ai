# Tamshai Enterprise AI - Integration Tests

## Quick Start - Running Integration Tests

```bash
# Prerequisites: Ensure Terraform has generated the .env file
cd infrastructure/terraform/dev && terraform apply -var-file=dev.tfvars

# Install test dependencies (includes dotenv for .env loading)
cd tests/integration && npm install

# Run integration tests (all env vars auto-loaded from .env)
npm test
```

Environment variables are automatically derived from `infrastructure/docker/.env` which is generated by Terraform from GitHub Secrets and Variables. The `jest.config.js` loads this file via `dotenv` and derives service URLs from `PORT_*` variables. No manual configuration required.

> **Keycloak `/auth` Prefix**: Local dev Keycloak is configured with `KC_HTTP_RELATIVE_PATH=/auth` (set in docker-compose.yml). The `jest.config.js` automatically appends `/auth` when deriving `KEYCLOAK_URL` from `PORT_KEYCLOAK`. CI Keycloak runs at root path (no `/auth`) and sets `KEYCLOAK_URL` explicitly. If you override `KEYCLOAK_URL` manually, include the `/auth` suffix for local dev: `http://127.0.0.1:$PORT_KEYCLOAK/auth`.

> **Important**: Tests must run sequentially with `--runInBand` (configured in jest config).  
> Parallel test execution causes race conditions on shared Keycloak and database state.  
> See [Parallel Test Isolation Issues](#parallel-test-isolation-issues) for details.

---

## Overview

Comprehensive integration test suite for the Tamshai Enterprise AI system, covering:

* **Role-Based Access Control (RBAC)** across all services
* **All 19 MCP tools** (read + write operations)
* **Architecture v1.4 features** (truncation, confirmations, LLM-friendly errors)
* **Multi-role access patterns** (executive, department admin, manager, intern)
* **Performance testing** with large datasets

---

## Test Coverage

### Test Files

File
Tests
Coverage
`rbac.test.ts`
18 tests
Authentication, Authorization, User Info, AI Queries, Audit Logging
`mcp-tools.test.ts`
60+ tests
All 19 MCP tools, Multi-role access, Confirmations, Performance

### MCP Tools Tested (19 Total)

#### MCP HR (Port 3101) - 6 Tools

* ✅ `list_employees` - Read with truncation warnings
* ✅ `get_employee` - Read with LLM-friendly errors
* ✅ `get_org_chart` - Organizational hierarchy
* ✅ `get_performance_reviews` - Performance data with truncation
* ✅ `delete_employee` - Write with confirmation flow
* ✅ `update_salary` - Write with confirmation flow

#### MCP Finance (Port 3102) - 5 Tools

* ✅ `get_budget` - Department budget retrieval
* ✅ `list_invoices` - Invoice listing with truncation
* ✅ `get_expense_report` - Employee expense reports
* ✅ `delete_invoice` - Write with confirmation flow
* ✅ `approve_budget` - Write with confirmation flow

#### MCP Sales (Port 3103) - 5 Tools

* ✅ `get_customer` - Customer details
* ✅ `list_opportunities` - Sales pipeline with truncation
* ✅ `get_pipeline` - Sales pipeline summary
* ✅ `delete_customer` - Write with confirmation flow
* ✅ `close_opportunity` - Write with confirmation flow

#### MCP Support (Port 3104) - 3 Tools

* ✅ `search_tickets` - Ticket search with truncation
* ✅ `get_knowledge_article` - KB article retrieval
* ✅ `close_ticket` - Write with confirmation flow

---

## Test Scenarios

### 1\. Read Tool Tests

**Coverage**: All read tools across 4 MCP servers

**Scenarios**:

* ✅ Successful data retrieval with `status: 'success'`
* ✅ LLM-friendly error responses for not found
* ✅ Truncation metadata for large result sets (\>50 records)
* ✅ Filtering by department/status/stage
* ✅ Query parameter validation

**Example**:

    `// Test: list_employees returns pagination metadata  
    const response = await hrClient.post('/tools/list_employees', {  
    userContext: { userId, roles },  
    limit: 50  
    });  
      
    expect(response.data.status).toBe('success');  
    if (response.data.metadata?.hasMore) {  
    expect(response.data.metadata.nextCursor).toBeDefined();  
    expect(response.data.metadata.totalEstimate).toMatch(/\d+\+/);  
    }  
    `

### 2\. Write Tool Tests (Confirmations)

**Coverage**: All write tools (8 total)

**Scenarios**:

* ✅ Returns `status: 'pending_confirmation'`
* ✅ Includes `confirmationId` (UUID)
* ✅ Provides human-readable `message`
* ✅ Stores confirmation in Redis with 5-minute TTL
* ✅ Includes `confirmationData` for UI display

**Example**:

    `// Test: delete_employee requires confirmation  
    const response = await hrClient.post('/tools/delete_employee', {  
    userContext: { userId, roles },  
    employeeId: 'f104eddc-21ab-457c-a254-78051ad7ad67'  
    });  
      
    expect(response.data.status).toBe('pending_confirmation');  
    expect(response.data.confirmationId).toBeDefined();  
    expect(response.data.message).toContain('Delete employee');  
    `

### 3\. Multi-Role Access Control

**Coverage**: 5 user roles × 4 MCP servers = 20 combinations

**Test Users**:
Username
Role
Access
`eve.thompson`
Executive
All 4 MCP servers (read/write)
`alice.chen`
HR Admin
MCP HR only
`bob.martinez`
Finance Admin
MCP Finance only
`carol.johnson`
Sales Admin
MCP Sales only
`dan.williams`
Support Admin
MCP Support only
`nina.patel`
Manager
Team data only (via RLS)
`frank.davis`
Intern
No MCP access (401/403)

**Scenarios**:

* ✅ Executive can access all departments
* ✅ Department admins can access only their MCP server
* ✅ Cross-department access is denied (403)
* ✅ Intern role has no MCP access
* ✅ Manager sees filtered data (RLS)

**Example**:

    `// Test: HR user cannot access Finance data  
    const hrToken = await getAccessToken('alice.chen', '[REDACTED-DEV-PASSWORD]');  
    const financeClient = createMcpClient(financeUrl, hrToken, userId);  
      
    try {  
    await financeClient.post('/tools/get_budget', { department: 'Engineering' });  
    fail('Should have thrown authorization error');  
    } catch (error) {  
    expect(error.response.status).toBeGreaterThanOrEqual(401);  
    }  
    `

### 4\. LLM-Friendly Error Responses (v1.4)

**Coverage**: All read tools

**Error Schema**:

    `{  
    status: 'error',  
    code: 'EMPLOYEE_NOT_FOUND',  // Machine-readable code  
    message: 'Employee with ID abc not found.',  // Human-readable  
    suggestedAction: 'Use list_employees tool to find valid employee IDs.'  // AI guidance  
    }  
    `

**Scenarios**:

* ✅ Not found errors include `suggestedAction`
* ✅ Invalid input errors suggest valid formats
* ✅ Authorization errors explain access requirements
* ✅ Errors are always status 200 (tool-level errors, not HTTP errors)

### 5\. Pagination & Truncation (v1.4)

**Coverage**: All list/search tools

**Metadata Schema** (cursor-based pagination):

    `{  
    metadata: {  
    hasMore: true,            // More records available  
    nextCursor: 'abc123...',  // Base64 cursor for next page  
    totalEstimate: '50+',     // Estimated total count  
    hint: 'Use nextCursor to fetch more records'  
    }  
    }  
    `

**Scenarios**:

* ✅ Results \>50 records include pagination metadata with nextCursor
* ✅ AI-visible hints in metadata for pagination
* ✅ Exact count provided for ≤50 results
* ✅ Cursor-based pagination for retrieving all results (tested with 59 employees)

### 6\. Performance Tests

**Coverage**: Concurrent requests, large datasets

**Scenarios**:

* ✅ Single query completes within 2 seconds (50 records)
* ✅ Truncation detection overhead <100ms
* ✅ 5 concurrent queries complete successfully
* ✅ No timeout errors under normal load

**Performance Targets**:

* Single query (50 records): < 2 seconds
* Truncation overhead: < 100ms
* Concurrent queries (5x): All succeed, no timeouts

---

## Prerequisites

### 1\. Backend Services Running

All services must be up and healthy:

    `cd infrastructure/docker  
    docker compose up -d  
      
    # Verify all services are healthy  
    docker compose ps  
    `

**Required Services**:

* ✅ Keycloak (port from `PORT_KEYCLOAK` env var)
* ✅ PostgreSQL (port from `PORT_POSTGRES` env var)
* ✅ MongoDB (port from `PORT_MONGODB` env var)
* ✅ Elasticsearch (port from `PORT_ELASTICSEARCH` env var)
* ✅ Redis (port from `PORT_REDIS` env var)
* ✅ MCP HR (port from `PORT_MCP_HR` env var)
* ✅ MCP Finance (port from `PORT_MCP_FINANCE` env var)
* ✅ MCP Sales (port from `PORT_MCP_SALES` env var)
* ✅ MCP Support (port from `PORT_MCP_SUPPORT` env var)

### 2\. Authentication Configuration

**Preferred Method: Token Exchange (February 2026)**

Integration tests now use the `mcp-integration-runner` service account for secure authentication:

```bash
# Load integration test secret from GitHub
eval $(../../scripts/secrets/read-github-secrets.sh --integration --env)

# Or set manually (local dev)
export MCP_INTEGRATION_RUNNER_SECRET="<secret-from-github-secrets>"

# Run tests (will use token exchange automatically)
npm test
```

**Service Account Details**:
* **Client ID**: `mcp-integration-runner`
* **Client Secret**: From `MCP_INTEGRATION_RUNNER_SECRET` environment variable
* **Authentication Flow**: Client Credentials → Token Exchange (impersonate test users)
* **Environment**: Dev and CI only (not created in stage/prod)

**Test Users** (impersonated via token exchange):

* `eve.thompson` - Executive
* `alice.chen` - HR Admin
* `bob.martinez` - Finance Admin
* `carol.johnson` - Sales Admin
* `dan.williams` - Support Admin
* `nina.patel` - Manager
* `marcus.johnson` - Engineer
* `frank.davis` - Intern

**IMPORTANT**: All 8 test users must exist in Keycloak for token exchange to work. No user passwords are needed — the `mcp-integration-runner` service account impersonates users via OAuth 2.0 Token Exchange (RFC 8693).

### 3\. Sample Data Loaded

Databases must contain sample data:

    `# PostgreSQL - HR & Finance  
    docker compose exec postgres psql -U tamshai -d tamshai_hr -c "SELECT COUNT(*) FROM hr.employees;"  
    # Expected: 59 employees (as of Jan 2026)  
      
    # MongoDB - Sales/CRM  
    docker compose exec mongodb mongosh -u admin -p [REDACTED-DEV-PASSWORD] --eval "db.customers.countDocuments()" tamshai_sales  
    # Expected: 15 customers  
      
    # Elasticsearch - Support  
    curl http://localhost:9201/support_tickets/_count  
    # Expected: 30+ tickets  
    `

---

## Running Tests

### Install Dependencies

    `cd tests/integration  
    npm install  
    `

**Dependencies**:

* `jest` - Test runner
* `ts-jest` - TypeScript support
* `axios` - HTTP client
* `@types/jest` - Type definitions

### Run All Tests

    `# Run all integration tests  
    npm test  
      
    # Run with coverage  
    npm test -- --coverage  
      
    # Run specific test file  
    npm test rbac.test.ts  
    npm test mcp-tools.test.ts  
    `

### Run Specific Test Suites

    `# RBAC tests only  
    npm test -- --testNamePattern="Authorization Tests"  
      
    # MCP HR tests only  
    npm test -- --testNamePattern="MCP HR Server"  
      
    # Confirmation flow tests only  
    npm test -- --testNamePattern="Write Tools"  
      
    # Performance tests only  
    npm test -- --testNamePattern="Performance Tests"  
    `

### Watch Mode (Development)

    `# Re-run tests on file changes  
    npm test -- --watch  
      
    # Watch specific file  
    npm test -- --watch rbac.test.ts  
    `

---

## Test Results Interpretation

### Success Criteria

**All tests should pass** if:

* ✅ All backend services are healthy
* ✅ Keycloak users are configured correctly
* ✅ Sample data is loaded in all databases
* ✅ MCP servers are implementing v1.4 response schemas

### Common Failures and Fixes

#### 1\. Authentication Failures

**Error**: `401 Unauthorized` on Keycloak token requests

**Fix**:

```bash
# Verify Keycloak is running (note: /auth prefix required for local dev)
curl http://localhost:$PORT_KEYCLOAK/auth/health/ready

# Check test user exists (prefer client credentials for admin token)
ADMIN_TOKEN=$(curl -s -X POST http://localhost:$PORT_KEYCLOAK/auth/realms/master/protocol/openid-connect/token \
  -d "client_id=admin-cli" \
  -d "client_secret=$KEYCLOAK_ADMIN_CLIENT_SECRET" \
  -d "grant_type=client_credentials" | \
  jq -r '.access_token')

curl -s "http://localhost:$PORT_KEYCLOAK/auth/admin/realms/tamshai-corp/users" \
  -H "Authorization: Bearer $ADMIN_TOKEN" | jq '.[] | select(.username=="alice.chen")'
```

#### 2\. MCP Server Connection Failures

**Error**: `ECONNREFUSED` on MCP tool calls

**Fix**:

    `# Check MCP server is running
    docker compose ps mcp-hr

    # Check health endpoint (port from PORT_MCP_HR env var)
    curl http://localhost:$PORT_MCP_HR/health

    # View logs
    docker compose logs mcp-hr --tail=50
    `

#### 3\. Tool Not Found Errors

**Error**: `404 Not Found` on tool endpoints

**Fix**:

* Verify MCP server has implemented the tool
* Check tool endpoint path: `/tools/{tool_name}`
* Review MCP server logs for routing errors

#### 4\. Pagination Metadata Missing

**Error**: Test expects `metadata.hasMore` or `metadata.nextCursor` but it's undefined

**Fix**:

* Ensure MCP server implements LIMIT+1 pattern with cursor-based pagination:

    `const result = await db.query('SELECT * FROM employees LIMIT $1', [limit + 1]);  
    const hasMore = result.rows.length > limit;  
    const data = result.rows.slice(0, limit);  
    const lastRecord = data[data.length - 1];  
    `

* Add pagination metadata to response:

    `return {  
    status: 'success',  
    data: data,  
    metadata: hasMore ? {  
    hasMore: true,  
    nextCursor: encodeCursor({ id: lastRecord.id, ... }),  
    totalEstimate: \`${limit}+\`,  
    hint: 'Use nextCursor to fetch more records'  
    } : undefined  
    };  
    `

#### 5\. Confirmation Flow Failures

**Error**: Write tools return `success` instead of `pending_confirmation`

**Fix**:

* Ensure write tools store confirmation in Redis:

    `const confirmationId = crypto.randomUUID();  
    await redis.setex(\`pending:${confirmationId}\`, 300, JSON.stringify({  
    action: 'delete_employee',  
    employeeId,  
    userId  
    }));  

    return {  
    status: 'pending_confirmation',  
    confirmationId,  
    message: '⚠️ Delete employee ...',  
    confirmationData: { employeeId, employeeName }  
    };  
    `

---

## CI/CD Integration

### GitHub Actions Workflow

Add to `.github/workflows/integration-tests.yml`:

    `name: Integration Tests  
      
    on:  
    push:  
    branches: [main]  
    pull_request:  
    branches: [main]  
      
    jobs:  
    test:  
    runs-on: ubuntu-latest  
      
    steps:  
    - uses: actions/checkout@v3  
      
    - name: Start services  
    run: |  
    cd infrastructure/docker  
    docker compose up -d  
    sleep 30  # Wait for services to be ready  
      
    - name: Setup Node.js  
    uses: actions/setup-node@v3  
    with:  
    node-version: '20'  
      
    - name: Install dependencies  
    run: |  
    cd tests/integration  
    npm install  
      
    - name: Run integration tests  
    run: |  
    cd tests/integration  
    npm test -- --ci --coverage  
      
    - name: Upload coverage  
    uses: codecov/codecov-action@v3  
    with:  
    files: ./tests/integration/coverage/lcov.info  
    `

---

## Test Maintenance

### Adding New Tools

When adding new MCP tools, update `mcp-tools.test.ts`:

1. **Add tool test in appropriate section**:  

    `describe('new_tool_name', () => {  
    test('Returns expected response', async () => {  
    const response = await mcpClient.post('/tools/new_tool_name', {  
    userContext: { userId, roles },  
    // ... tool input  
    });  

    expect(response.data.status).toBe('success');  
    // ... assertions  
    });  
    });  
    `

2. **Update tool count** in this README (currently 19 tools)  
3. **Run tests** to verify new tool works:  

    `npm test -- --testNamePattern="new_tool_name"  
    `

### Updating Test Users

If user UUIDs change:

1. Query PostgreSQL for new UUIDs:  

    `docker compose exec postgres psql -U tamshai -d tamshai_hr -c \  
    "SELECT employee_id, email FROM hr.employees WHERE email LIKE '%.chen%';"  
    `

2. Update `TEST_USERS` object in test files  
3. Re-run tests  

---

## Performance Benchmarks

### Current Performance (as of Dec 2025)

Operation
Target
Actual
Status
Single query (50 records)
< 2s
~800ms
✅ Pass
Truncation overhead
< 100ms
~30ms
✅ Pass
Concurrent queries (5x)
All succeed
5/5 success
✅ Pass
Health check
< 500ms
~150ms
✅ Pass

### Monitoring Performance

Run performance tests separately:

    `npm test -- --testNamePattern="Performance Tests" --verbose  
    `

Look for timing information in test output:

    ` ✓ list_employees completes within 2 seconds for 50 records (823 ms)  
    ✓ Truncation detection adds minimal overhead (<100ms) (67 ms)  
    ✓ Concurrent tool calls complete successfully (1234 ms)  
    `

---

## Troubleshooting

### Debug Mode

Enable verbose logging:

    `# Set DEBUG environment variable  
    DEBUG=* npm test  
      
    # Or use Jest's verbose flag  
    npm test -- --verbose  
    `

### Inspect HTTP Requests

Add request/response logging to test file:

    `axios.interceptors.request.use(request => {  
    console.log('Request:', request.method, request.url, request.data);  
    return request;  
    });  
      
    axios.interceptors.response.use(response => {  
    console.log('Response:', response.status, response.data);  
    return response;  
    });  
    `

### Check Redis Confirmations

Verify confirmations are being stored:

    `# List all pending confirmations  
    docker compose exec redis redis-cli KEYS "pending:*"  
      
    # Get confirmation details  
    docker compose exec redis redis-cli GET "pending:{confirmation-id}"  
      
    # Check TTL  
    docker compose exec redis redis-cli TTL "pending:{confirmation-id}"  
    `

### Database Query Verification

Test RLS policies directly:

    `# Connect as specific user  
    docker compose exec postgres psql -U tamshai -d tamshai_hr  
      
    # Set session variables  
    SET LOCAL app.current_user_id = 'f104eddc-21ab-457c-a254-78051ad7ad67';  
    SET LOCAL app.current_user_roles = 'hr-read';  
      
    # Query should be filtered  
    SELECT * FROM hr.employees;  
    `

---

## Contributing

When adding new integration tests:

1. **Follow existing patterns**: Use same test structure and naming conventions
2. **Test v1.4 features**: Always test truncation, confirmations, and error schemas
3. **Include multi-role tests**: Test both authorized and unauthorized access
4. **Add documentation**: Update this README with new test scenarios
5. **Run all tests**: Ensure new tests don't break existing ones

---

## Parallel Test Isolation Issues

Integration tests **must run sequentially** (`--runInBand`) due to the following shared state dependencies:

### 1\. Keycloak TOTP Management (Race Condition)

The `setup.ts` file manages Keycloak user configurations:

* `beforeAll`: Removes `CONFIGURE_TOTP` required action from test users
* `afterAll`: Restores TOTP requirements for all users

When tests run in parallel, each test file's hooks execute concurrently, causing race conditions on shared Keycloak user state.

### 2\. Database Fixture Resets (State Conflicts)

Multiple test files reset overlapping database fixtures:

* `expense-reports.test.ts`: Resets expense report statuses in `beforeAll`, `beforeEach`, and `afterAll`
* `budget-approval.test.ts`: Resets budget fixtures in `beforeAll` and `beforeEach`

These resets use `getAdminPoolFinanceReset()` with `BYPASSRLS` to update records directly. When running in parallel, one file's reset can interfere with another file's test expectations.

### 3\. Shared Connection Pools

The `setup.ts` maintains shared database pools:

* `adminPool` (HR database)
* `adminPoolFinance` (Finance database)
* `adminPoolFinanceReset` (Finance with BYPASSRLS)

When one test file's `afterAll` closes these pools, other running tests lose their database connections.

### Solution

The Jest configuration uses `--runInBand` to run tests sequentially:

    `{  
    "testTimeout": 30000,  
    "maxWorkers": 1  
    }  
    `

Do not attempt to parallelize integration tests without first:

1. Isolating Keycloak modifications per test file
2. Using separate database fixtures per test file (no overlap)
3. Creating per-file connection pools

---

## Related Documentation

* [Architecture Overview](../../docs/architecture/overview.md)
* [Security Model](../../docs/architecture/security-model.md)
* [MCP Suite Specification](../../.specify/specs/004-mcp-suite/spec.md)
* [Architecture v1.4 Changes](../../.specify/ARCHITECTURE_V1.4_CHANGES.md)

---

**Last Updated**: February 8, 2026  
**Test Count**: 96 tests (89 passed, 7 skipped in CI)  
**Coverage**: All 19 MCP tools, 5 user roles, 4 v1.4 features, cursor-based pagination  
**Related**: See `.specify/specs/011-qa-testing/TEST_COVERAGE_STRATEGY.md` for overall project coverage (80.8%)
