#cloud-config
# Tamshai Enterprise AI - VPS Bootstrap Configuration
# This cloud-init script fully provisions a VPS without manual SSH access

package_update: true
package_upgrade: true

packages:
  - apt-transport-https
  - ca-certificates
  - curl
  - gnupg
  - lsb-release
  - git
  - jq
  - unzip
  - htop
  - fail2ban

# Set root password for console access
chpasswd:
  expire: false
  users:
    - name: root
      password: ${root_password}
      type: text

# Create tamshai user for running services
users:
  - name: tamshai
    groups: docker
    shell: /bin/bash
    sudo: ALL=(ALL) NOPASSWD:ALL
    lock_passwd: true

write_files:
  # Environment file with secrets (temporary location)
  - path: /tmp/tamshai.env
    permissions: '0600'
    content: |
      # Tamshai Enterprise AI - Environment Configuration
      # Auto-generated by Terraform - DO NOT EDIT MANUALLY

      ENVIRONMENT=${environment}
      DOMAIN=${domain}

      # Keycloak
      KEYCLOAK_ADMIN=admin
      KEYCLOAK_ADMIN_PASSWORD=${keycloak_admin_pass}
      KC_HOSTNAME=${domain}
      KC_HOSTNAME_STRICT=false
      KC_HTTP_RELATIVE_PATH=/auth
      KC_PROXY=edge
      KC_DB=postgres
      KC_DB_URL=jdbc:postgresql://postgres:5432/keycloak
      KC_DB_USERNAME=keycloak
      KC_DB_PASSWORD=${keycloak_db_password}

      # PostgreSQL
      POSTGRES_USER=postgres
      POSTGRES_PASSWORD=${postgres_password}
      KEYCLOAK_DB_PASSWORD=${keycloak_db_password}
      TAMSHAI_DB_PASSWORD=${postgres_password}

      # MongoDB
      MONGO_INITDB_ROOT_USERNAME=tamshai
      MONGO_INITDB_ROOT_PASSWORD=${mongodb_password}
      MONGODB_PASSWORD=${mongodb_password}

      # MinIO
      MINIO_ROOT_USER=minioadmin
      MINIO_ROOT_PASSWORD=${minio_password}

      # MCP Gateway
      CLAUDE_API_KEY=${claude_api_key}
      JWT_SECRET=${jwt_secret}
      KEYCLOAK_URL=https://${domain}/auth
      KEYCLOAK_ISSUER=https://${domain}/auth/realms/tamshai
      JWKS_URI=http://keycloak:8080/auth/realms/tamshai/protocol/openid-connect/certs
      KEYCLOAK_REALM=tamshai

      # Web Apps
      VITE_KEYCLOAK_URL=https://${domain}/auth
      VITE_KEYCLOAK_CLIENT_ID=mcp-gateway
      VITE_MCP_GATEWAY_URL=https://${domain}/api

      # Logging
      LOG_LEVEL=info

      # Feature Flags
      ENABLE_AUDIT_LOGGING=true
      ENABLE_RATE_LIMITING=true

  # Caddyfile for reverse proxy behind Cloudflare
  - path: /opt/tamshai/Caddyfile
    permissions: '0644'
    content: |
      # Tamshai Enterprise AI - Caddy Reverse Proxy
      # Path-based routing (no subdomains required)
      # HTTP-only - Cloudflare handles TLS termination

      {
        # Disable automatic HTTPS (Cloudflare handles TLS)
        auto_https off
        # Trust Cloudflare proxy headers
        servers {
          trusted_proxies static 173.245.48.0/20 103.21.244.0/22 103.22.200.0/22 103.31.4.0/22 141.101.64.0/18 108.162.192.0/18 190.93.240.0/20 188.114.96.0/20 197.234.240.0/22 198.41.128.0/17 162.158.0.0/15 104.16.0.0/13 104.24.0.0/14 172.64.0.0/13 131.0.72.0/22 2400:cb00::/32 2606:4700::/32 2803:f800::/32 2405:b500::/32 2405:8100::/32 2a06:98c0::/29 2c0f:f248::/32
        }
      }

      # Listen on HTTP only (port 80) - Cloudflare proxies to this
      :80 {
        encode gzip

        header {
          X-Content-Type-Options nosniff
          X-Frame-Options SAMEORIGIN
          Referrer-Policy strict-origin-when-cross-origin
          -Server
        }

        # Keycloak authentication (/auth/*)
        handle_path /auth/* {
          reverse_proxy keycloak:8080
        }

        # MCP Gateway API (/api/*)
        handle /api/* {
          header {
            Access-Control-Allow-Origin *
            Access-Control-Allow-Methods "GET, POST, OPTIONS"
            Access-Control-Allow-Headers "Authorization, Content-Type"
          }

          # SSE streaming support
          @sse {
            path /api/query*
            header Accept text/event-stream
          }
          reverse_proxy @sse mcp-gateway:3100 {
            flush_interval -1
            transport http {
              read_timeout 120s
              write_timeout 120s
            }
          }

          reverse_proxy mcp-gateway:3100
        }

        # HR App (/hr/*)
        handle_path /hr/* {
          reverse_proxy web-hr:80
        }

        # Finance App (/finance/*)
        handle_path /finance/* {
          reverse_proxy web-finance:80
        }

        # Sales App (/sales/*)
        handle_path /sales/* {
          reverse_proxy web-sales:80
        }

        # Support App (/support/*)
        handle_path /support/* {
          reverse_proxy web-support:80
        }

        # Web Portal (/app/*)
        handle_path /app/* {
          reverse_proxy web-portal:80
        }

        # Corporate website (default - static site at root)
        handle {
          reverse_proxy tamshai-website:80
        }
      }

  # Deploy script for remote updates
  - path: /opt/tamshai/scripts/deploy.sh
    permissions: '0755'
    content: |
      #!/bin/bash
      # Tamshai Enterprise AI - Deployment Script
      # Usage: ./deploy.sh [--build] [--pull]

      set -e

      cd /opt/tamshai

      echo "=== Tamshai Deployment $(date) ==="

      # Parse arguments
      BUILD_FLAG=""
      PULL_ONLY=false

      while [[ $# -gt 0 ]]; do
        case $1 in
          --build)
            BUILD_FLAG="--build"
            shift
            ;;
          --pull)
            PULL_ONLY=true
            shift
            ;;
          *)
            echo "Unknown option: $1"
            exit 1
            ;;
        esac
      done

      # Pull latest code
      echo "Pulling latest code from ${github_branch}..."
      git fetch origin
      git reset --hard origin/${github_branch}

      if [ "$PULL_ONLY" = true ]; then
        echo "Pull complete. Exiting."
        exit 0
      fi

      # Load environment
      export $(cat .env | grep -v '^#' | xargs)

      # Pull latest images
      echo "Pulling Docker images..."
      docker compose -f docker-compose.vps.yml pull

      # Deploy with optional build
      echo "Deploying services..."
      docker compose -f docker-compose.vps.yml up -d $BUILD_FLAG

      # Cleanup old images
      echo "Cleaning up..."
      docker image prune -f

      # Health check
      echo "Waiting for services to be healthy..."
      sleep 30

      # Check key services
      echo "Checking service health..."
      curl -sf http://localhost:3100/health > /dev/null && echo "✓ MCP Gateway: healthy" || echo "✗ MCP Gateway: unhealthy"
      curl -sf http://localhost:8080/auth/health > /dev/null && echo "✓ Keycloak: healthy" || echo "✗ Keycloak: unhealthy"

      echo "=== Deployment complete ==="

  # Webhook handler for GitHub Actions
  - path: /opt/tamshai/scripts/webhook-handler.sh
    permissions: '0755'
    content: |
      #!/bin/bash
      # Handles deployment webhooks from GitHub Actions

      # Validate webhook secret
      EXPECTED_SECRET="$(cat /opt/tamshai/.webhook-secret)"
      RECEIVED_SECRET="$1"

      if [ "$RECEIVED_SECRET" != "$EXPECTED_SECRET" ]; then
        echo "Invalid webhook secret"
        exit 1
      fi

      # Trigger deployment
      /opt/tamshai/scripts/deploy.sh --build 2>&1 | tee -a /var/log/tamshai-deploy.log

  # Systemd service for auto-updates (optional)
  - path: /etc/systemd/system/tamshai-deploy.service
    permissions: '0644'
    content: |
      [Unit]
      Description=Tamshai Deployment Service
      After=docker.service

      [Service]
      Type=oneshot
      WorkingDirectory=/opt/tamshai
      ExecStart=/opt/tamshai/scripts/deploy.sh
      User=tamshai
      StandardOutput=journal
      StandardError=journal

  # Timer for scheduled updates (optional - disabled by default)
  - path: /etc/systemd/system/tamshai-deploy.timer
    permissions: '0644'
    content: |
      [Unit]
      Description=Tamshai Scheduled Deployment

      [Timer]
      OnCalendar=*-*-* 04:00:00
      Persistent=true

      [Install]
      WantedBy=timers.target

  # Fail2ban configuration
  - path: /etc/fail2ban/jail.local
    permissions: '0644'
    content: |
      [DEFAULT]
      bantime = 3600
      findtime = 600
      maxretry = 5

      [sshd]
      enabled = true
      port = ssh
      filter = sshd
      logpath = /var/log/auth.log
      maxretry = 3

runcmd:
  # Install Docker
  - curl -fsSL https://get.docker.com | sh
  - systemctl enable docker
  - systemctl start docker
  - usermod -aG docker tamshai

  # Install Docker Compose plugin
  - mkdir -p /usr/local/lib/docker/cli-plugins
  - curl -SL "https://github.com/docker/compose/releases/latest/download/docker-compose-linux-$(uname -m)" -o /usr/local/lib/docker/cli-plugins/docker-compose
  - chmod +x /usr/local/lib/docker/cli-plugins/docker-compose

  # Clone repository to temporary location (write_files already created /opt/tamshai)
  - git clone --branch ${github_branch} ${github_repo} /tmp/tamshai-repo

  # Move repository files to /opt/tamshai (merge with existing Caddyfile/scripts from write_files)
  - cp -r /tmp/tamshai-repo/. /opt/tamshai/
  - rm -rf /tmp/tamshai-repo

  # Move generated .env file from temp location
  - mv /tmp/tamshai.env /opt/tamshai/.env

  # Set ownership
  - chown -R tamshai:tamshai /opt/tamshai

  # Generate webhook secret
  - openssl rand -hex 32 > /opt/tamshai/.webhook-secret
  - chmod 600 /opt/tamshai/.webhook-secret
  - chown tamshai:tamshai /opt/tamshai/.webhook-secret

  # Start services
  - cd /opt/tamshai && docker compose -f docker-compose.vps.yml pull
  - cd /opt/tamshai && docker compose -f docker-compose.vps.yml up -d

  # Enable fail2ban
  - systemctl enable fail2ban
  - systemctl start fail2ban

  # Setup log rotation
  - |
    cat > /etc/logrotate.d/tamshai << 'EOF'
    /var/log/tamshai-*.log {
      daily
      rotate 7
      compress
      delaycompress
      missingok
      notifempty
    }
    EOF

  # Final status
  - echo "Tamshai VPS setup complete at $(date)" >> /var/log/cloud-init-output.log
