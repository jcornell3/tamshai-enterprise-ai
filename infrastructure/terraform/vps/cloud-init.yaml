#cloud-config
# Tamshai Enterprise AI - VPS Bootstrap Configuration
# This cloud-init script fully provisions a VPS without manual SSH access

package_update: true
package_upgrade: true

packages:
  - apt-transport-https
  - ca-certificates
  - curl
  - gnupg
  - lsb-release
  - git
  - jq
  - unzip
  - htop
  - fail2ban

# Set root password for console access
chpasswd:
  expire: false
  users:
    - name: root
      password: "${root_password}"
      type: text

# Create tamshai user for running services
users:
  - name: tamshai
    groups: docker
    shell: /bin/bash
    sudo: ALL=(ALL) NOPASSWD:ALL
    lock_passwd: true

write_files:
  # Environment file with secrets (temporary location)
  - path: /tmp/tamshai.env
    permissions: '0600'
    content: |
      # Tamshai Enterprise AI - Environment Configuration
      # Auto-generated by Terraform - DO NOT EDIT MANUALLY

      ENVIRONMENT=${environment}
      DOMAIN=${domain}

      # Keycloak
      KEYCLOAK_ADMIN=admin
      KEYCLOAK_ADMIN_PASSWORD=${keycloak_admin_pass}
      KC_HOSTNAME=${domain}
      KC_HOSTNAME_STRICT=false
      KC_HTTP_RELATIVE_PATH=/auth
      KC_PROXY=edge
      KC_DB=postgres
      KC_DB_URL=jdbc:postgresql://postgres:5432/keycloak
      KC_DB_USERNAME=keycloak
      KC_DB_PASSWORD=${keycloak_db_password}

      # PostgreSQL
      POSTGRES_USER=postgres
      POSTGRES_PASSWORD=${postgres_password}
      KEYCLOAK_DB_PASSWORD=${keycloak_db_password}
      TAMSHAI_DB_PASSWORD=${postgres_password}

      # MongoDB
      MONGO_INITDB_ROOT_USERNAME=tamshai
      MONGO_INITDB_ROOT_PASSWORD=${mongodb_password}
      MONGODB_PASSWORD=${mongodb_password}

      # MinIO
      MINIO_ROOT_USER=minioadmin
      MINIO_ROOT_PASSWORD=${minio_password}

      # MCP Gateway
      CLAUDE_API_KEY=${claude_api_key}
      JWT_SECRET=${jwt_secret}
      KEYCLOAK_URL=https://${domain}/auth
      KEYCLOAK_ISSUER=https://${domain}/auth/realms/tamshai-corp
      JWKS_URI=http://keycloak:8080/auth/realms/tamshai-corp/protocol/openid-connect/certs
      # KEYCLOAK_REALM is the path to realm export file (used in docker-compose volumes)
      # Stage uses pre-seeded users with group assignments for Phoenix architecture
      KEYCLOAK_REALM=./keycloak/realm-export-stage.json

      # Identity Sync (HR -> Keycloak provisioning)
      MCP_HR_SERVICE_CLIENT_SECRET=${mcp_hr_service_client_secret}

      # Keycloak client secrets (must match realm-export-stage.json)
      MCP_GATEWAY_CLIENT_SECRET=mcp-gateway-secret

      # Docker compose settings for VPS
      COMPOSE_PROJECT_NAME=tamshai-vps
      KEYCLOAK_MODE=start

      # Use VPS-specific Caddyfile (HTTP-only, Cloudflare handles TLS)
      CADDYFILE=./infrastructure/docker/Caddyfile.stage

      # Web Apps
      # NOTE: Authority URL must include full realm path for OIDC discovery
      VITE_KEYCLOAK_URL=https://${domain}/auth/realms/tamshai-corp
      VITE_KEYCLOAK_CLIENT_ID=web-portal
      VITE_MCP_GATEWAY_URL=https://${domain}/api

      # Logging
      LOG_LEVEL=info

      # MCP Support Backend Selection
      SUPPORT_DATA_BACKEND=elasticsearch

      # Feature Flags
      ENABLE_AUDIT_LOGGING=true
      ENABLE_RATE_LIMITING=true

      # User Password - Fixed password for synced users (from STAGE_USER_PASSWORD secret)
      USER_PASSWORD=${stage_user_password}

      # Test User Credentials (from GitHub Secrets - Phoenix Architecture)
      # Used by Keycloak Admin API to set test-user.journey password and TOTP
      TEST_USER_PASSWORD=${test_user_password}
      TEST_USER_TOTP_SECRET_RAW=${test_user_totp_secret_raw}

  # NOTE: Caddyfile is NOT embedded here (Phoenix principle: single source of truth)
  # Instead, it's copied from infrastructure/docker/Caddyfile.stage in runcmd section
  # See: https://github.com/jcornell3/tamshai-enterprise-ai/blob/main/infrastructure/docker/Caddyfile.stage

  # Deploy script for remote updates
  - path: /opt/tamshai/scripts/deploy.sh
    permissions: '0755'
    content: |
      #!/bin/bash
      # Tamshai Enterprise AI - Deployment Script
      # Usage: ./deploy.sh [--build] [--pull]

      set -e
      set +H  # Disable history expansion to handle passwords with special characters like !

      cd /opt/tamshai

      echo "=== Tamshai Deployment $(date) ==="

      # Parse arguments
      BUILD_FLAG=""
      NO_CACHE_FLAG=""
      PULL_ONLY=false

      while [[ $# -gt 0 ]]; do
        case $1 in
          --build)
            BUILD_FLAG="--build"
            NO_CACHE_FLAG="--no-cache"
            shift
            ;;
          --pull)
            PULL_ONLY=true
            shift
            ;;
          *)
            echo "Unknown option: $1"
            exit 1
            ;;
        esac
      done

      # Pull latest code
      echo "Pulling latest code from ${github_branch}..."
      git fetch origin
      git reset --hard origin/${github_branch}

      if [ "$PULL_ONLY" = true ]; then
        echo "Pull complete. Exiting."
        exit 0
      fi

      # Load environment
      export $(cat .env | grep -v '^#' | xargs)

      # Pull latest images
      echo "Pulling Docker images..."
      docker compose pull

      # Deploy with optional build (uses root docker-compose.yml)
      echo "Deploying services..."
      if [ -n "$BUILD_FLAG" ]; then
        docker compose build $NO_CACHE_FLAG && docker compose up -d
      else
        docker compose up -d
      fi

      # Cleanup old images
      echo "Cleaning up..."
      docker image prune -f

      # Health check
      echo "Waiting for services to be healthy..."
      sleep 30

      # Check key services
      echo "Checking service health..."
      curl -sf http://localhost:3100/health > /dev/null && echo "✓ MCP Gateway: healthy" || echo "✗ MCP Gateway: unhealthy"
      # Keycloak health check (using nc since curl may not be in container)
      echo "GET /health/ready HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n" | nc localhost 8180 2>&1 | grep -q "200\|UP" && echo "✓ Keycloak: healthy" || echo "✗ Keycloak: unhealthy"

      echo "=== Deployment complete ==="

  # Webhook handler for GitHub Actions
  - path: /opt/tamshai/scripts/webhook-handler.sh
    permissions: '0755'
    content: |
      #!/bin/bash
      # Handles deployment webhooks from GitHub Actions

      # Validate webhook secret
      EXPECTED_SECRET="$(cat /opt/tamshai/.webhook-secret)"
      RECEIVED_SECRET="$1"

      if [ "$RECEIVED_SECRET" != "$EXPECTED_SECRET" ]; then
        echo "Invalid webhook secret"
        exit 1
      fi

      # Trigger deployment
      /opt/tamshai/scripts/deploy.sh --build 2>&1 | tee -a /var/log/tamshai-deploy.log

  # Systemd service for auto-updates (optional)
  - path: /etc/systemd/system/tamshai-deploy.service
    permissions: '0644'
    content: |
      [Unit]
      Description=Tamshai Deployment Service
      After=docker.service

      [Service]
      Type=oneshot
      WorkingDirectory=/opt/tamshai
      ExecStart=/opt/tamshai/scripts/deploy.sh
      User=tamshai
      StandardOutput=journal
      StandardError=journal

  # Timer for scheduled updates (optional - disabled by default)
  - path: /etc/systemd/system/tamshai-deploy.timer
    permissions: '0644'
    content: |
      [Unit]
      Description=Tamshai Scheduled Deployment

      [Timer]
      OnCalendar=*-*-* 04:00:00
      Persistent=true

      [Install]
      WantedBy=timers.target

  # Fail2ban configuration
  - path: /etc/fail2ban/jail.local
    permissions: '0644'
    content: |
      [DEFAULT]
      bantime = 3600
      findtime = 600
      maxretry = 5

      [sshd]
      enabled = true
      port = ssh
      filter = sshd
      logpath = /var/log/auth.log
      maxretry = 3

runcmd:
  # Install Docker
  - curl -fsSL https://get.docker.com | sh
  - systemctl enable docker
  - systemctl start docker
  - usermod -aG docker tamshai

  # Install Docker Compose plugin
  - mkdir -p /usr/local/lib/docker/cli-plugins
  - curl -SL "https://github.com/docker/compose/releases/latest/download/docker-compose-linux-$(uname -m)" -o /usr/local/lib/docker/cli-plugins/docker-compose
  - chmod +x /usr/local/lib/docker/cli-plugins/docker-compose

  # Clone repository to temporary location (write_files already created /opt/tamshai)
  - git clone --branch ${github_branch} ${github_repo} /tmp/tamshai-repo

  # Move repository files to /opt/tamshai (merge with existing scripts from write_files)
  - cp -r /tmp/tamshai-repo/. /opt/tamshai/
  - rm -rf /tmp/tamshai-repo

  # Copy Caddyfile from repo (Phoenix principle: single source of truth in version control)
  - cp /opt/tamshai/infrastructure/docker/Caddyfile.stage /opt/tamshai/Caddyfile

  # Move generated .env file from temp location
  - mv /tmp/tamshai.env /opt/tamshai/.env

  # Set ownership
  - chown -R tamshai:tamshai /opt/tamshai

  # Generate webhook secret
  - openssl rand -hex 32 > /opt/tamshai/.webhook-secret
  - chmod 600 /opt/tamshai/.webhook-secret
  - chown tamshai:tamshai /opt/tamshai/.webhook-secret

  # Start services (build from source with no cache, pull base images)
  # Uses root docker-compose.yml with VPS environment variables
  - cd /opt/tamshai && docker compose build --no-cache && docker compose up -d

  # Wait for Keycloak to be healthy before syncing
  - |
    echo "Waiting for Keycloak to be ready..."
    for i in 1 2 3 4 5 6 7 8 9 10; do
      if curl -sf http://localhost:8180/auth/health/ready >/dev/null 2>&1; then
        echo "Keycloak health check passed, waiting for admin API..."
        sleep 30
        echo "Keycloak is ready"
        break
      fi
      echo "Waiting for Keycloak... attempt $i/10"
      sleep 30
    done

  # Sync Keycloak realm configuration (creates clients, roles, mappers)
  # Copy entire scripts directory to include lib/*.sh dependencies
  # Note: Use sed to extract values after first '=' to handle passwords with special chars
  - |
    cd /opt/tamshai
    docker cp keycloak/scripts tamshai-keycloak:/tmp/keycloak-scripts
    docker exec -u 0 tamshai-keycloak bash -c 'find /tmp/keycloak-scripts -name "*.sh" -exec sed -i "s/\r$//" {} \; && chmod -R 755 /tmp/keycloak-scripts'
    KC_PASS=$(sed -n "s/^KEYCLOAK_ADMIN_PASSWORD=//p" .env)
    HR_SECRET=$(sed -n "s/^MCP_HR_SERVICE_CLIENT_SECRET=//p" .env)
    docker exec -e KEYCLOAK_ADMIN_PASSWORD="$KC_PASS" \
      -e MCP_HR_SERVICE_CLIENT_SECRET="$HR_SECRET" \
      tamshai-keycloak /tmp/keycloak-scripts/sync-realm.sh stage || echo "Keycloak sync failed - may need manual configuration"

  # NOTE: Identity sync is now handled by mcp-hr on startup (Phoenix Architecture)
  # The mcp-hr service automatically reconciles HR employees to Keycloak users
  # when it starts. This is self-healing and runs on every boot/restart.
  # See docs/operations/IDENTITY_SYNC.md for details.

  # Configure test-user.journey password and TOTP (Phoenix Architecture)
  # This uses the Keycloak Admin API to set credentials fetched from GitHub Secrets
  - |
    cd /opt/tamshai
    echo "Configuring test-user.journey credentials..."

    # Load credentials from .env
    TEST_USER_PASSWORD=$(sed -n "s/^TEST_USER_PASSWORD=//p" .env)
    TEST_USER_TOTP_SECRET_RAW=$(sed -n "s/^TEST_USER_TOTP_SECRET_RAW=//p" .env)
    KC_PASS=$(sed -n "s/^KEYCLOAK_ADMIN_PASSWORD=//p" .env)

    if [ -z "$TEST_USER_PASSWORD" ]; then
      echo "WARNING: TEST_USER_PASSWORD not set - E2E tests may fail"
    else
      # Get admin token from Keycloak
      echo "Getting admin token..."
      TOKEN_RESPONSE=$(curl -s -X POST "http://localhost:8180/auth/realms/master/protocol/openid-connect/token" \
        -H "Content-Type: application/x-www-form-urlencoded" \
        -d "username=admin" \
        -d "password=$KC_PASS" \
        -d "grant_type=password" \
        -d "client_id=admin-cli")

      TOKEN=$(echo "$TOKEN_RESPONSE" | jq -r '.access_token // empty')

      if [ -z "$TOKEN" ]; then
        echo "ERROR: Failed to get admin token"
        echo "Response: $TOKEN_RESPONSE"
      else
        echo "✓ Admin token obtained"

        # Get test-user.journey user ID
        echo "Finding test-user.journey..."
        USER_RESPONSE=$(curl -s "http://localhost:8180/auth/admin/realms/tamshai-corp/users?username=test-user.journey&exact=true" \
          -H "Authorization: Bearer $TOKEN")

        USER_ID=$(echo "$USER_RESPONSE" | jq -r '.[0].id // empty')

        if [ -z "$USER_ID" ]; then
          echo "WARNING: test-user.journey not found in Keycloak"
        else
          echo "User ID: $USER_ID"

          # Set password via REST API with jq for proper JSON encoding
          echo "Setting test-user.journey password..."
          PASSWORD_JSON=$(jq -n --arg pass "$TEST_USER_PASSWORD" '{"type":"password","value":$pass,"temporary":false}')
          HTTP_CODE=$(curl -s -o /dev/null -w "%%{http_code}" -X PUT \
            "http://localhost:8180/auth/admin/realms/tamshai-corp/users/$USER_ID/reset-password" \
            -H "Authorization: Bearer $TOKEN" \
            -H "Content-Type: application/json" \
            -d "$PASSWORD_JSON")

          if [ "$HTTP_CODE" = "204" ]; then
            echo "✓ test-user.journey password set successfully"
          else
            echo "ERROR: Failed to set test-user.journey password (HTTP $HTTP_CODE)"
          fi

          # Configure TOTP if secret is provided
          if [ -n "$TEST_USER_TOTP_SECRET_RAW" ]; then
            echo "Configuring TOTP for test-user.journey..."

            # Delete existing OTP credentials
            EXISTING_CREDS=$(curl -s "http://localhost:8180/auth/admin/realms/tamshai-corp/users/$USER_ID/credentials" \
              -H "Authorization: Bearer $TOKEN")

            for CRED_ID in $(echo "$EXISTING_CREDS" | jq -r '.[] | select(.type=="otp") | .id'); do
              echo "Deleting existing OTP credential: $CRED_ID"
              curl -s -X DELETE "http://localhost:8180/auth/admin/realms/tamshai-corp/users/$USER_ID/credentials/$CRED_ID" \
                -H "Authorization: Bearer $TOKEN"
            done

            # Create new OTP credential with the known secret
            echo "Creating OTP credential..."
            CREDENTIAL_JSON=$(cat <<EOF
    {
      "type": "otp",
      "userLabel": "Terraform Provisioned",
      "secretData": "{\"value\":\"$TEST_USER_TOTP_SECRET_RAW\"}",
      "credentialData": "{\"subType\":\"totp\",\"period\":30,\"digits\":6,\"algorithm\":\"HmacSHA1\",\"counter\":0}"
    }
    EOF
    )

            HTTP_CODE=$(curl -s -o /dev/null -w "%%{http_code}" -X POST \
              "http://localhost:8180/auth/admin/realms/tamshai-corp/users/$USER_ID/credentials" \
              -H "Authorization: Bearer $TOKEN" \
              -H "Content-Type: application/json" \
              -d "$CREDENTIAL_JSON")

            if [ "$HTTP_CODE" = "201" ] || [ "$HTTP_CODE" = "200" ] || [ "$HTTP_CODE" = "204" ]; then
              echo "✓ OTP credential created successfully (HTTP $HTTP_CODE)"
            else
              echo "WARNING: OTP credential creation returned HTTP $HTTP_CODE"
              echo "TOTP may need to be auto-captured by E2E tests"
            fi

            # Clear required actions to prevent TOTP setup prompt
            echo "Clearing required actions..."
            curl -s -X PUT \
              "http://localhost:8180/auth/admin/realms/tamshai-corp/users/$USER_ID" \
              -H "Authorization: Bearer $TOKEN" \
              -H "Content-Type: application/json" \
              -d '{"requiredActions":[]}' > /dev/null

            echo "✓ TOTP configuration complete"
          else
            echo "WARNING: TEST_USER_TOTP_SECRET_RAW not set - TOTP will be auto-captured by E2E tests"
          fi
        fi
      fi
    fi

    echo "test-user.journey credential configuration complete!"

  # Enable fail2ban
  - systemctl enable fail2ban
  - systemctl start fail2ban

  # Setup log rotation
  - |
    cat > /etc/logrotate.d/tamshai << 'EOF'
    /var/log/tamshai-*.log {
      daily
      rotate 7
      compress
      delaycompress
      missingok
      notifempty
    }
    EOF

  # Final status
  - echo "Tamshai VPS setup complete at $(date)" >> /var/log/cloud-init-output.log
